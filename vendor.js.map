{"version":3,"sources":["vendor/gibberish.js","vendor/keymaster.js","vendor/sonoport-soundmodels-core-lite.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CClwPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/vendor.js","sourcesContent":["!function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof exports === \"object\") {\n    module.exports = factory();\n  } else {\n  root.Gibberish = factory();\n  }\n}(this, function () {\n/**#Gibberish - Miscellaneous\nGibberish is the main object used to manage the audio graph and perform codegen functions. All constructors are also inside of the Gibberish object. Gibberish can automatically generate an appropriate web audio callback for you; if you want to use this you must execute the Gibberish.init() command before creating any Gibberish ugens.\n\n## Example Usage##\n`// make a sine wave  \nGibberish.init();  \na = new Gibberish.Sine().connect();`\n## Constructor\n**param** *bufferSize*: Integer. Default 1024. The size of the buffer to be calculated. Since JavaScript is single-threaded, setting exceedingly large values for this will yield to stuttering in graphics and user interface performance.\n- - - -\n**/\n/**###Gibberish.audioFiles : property  \nArray. Anytime an audiofile is loaded (normally using the Sampler ugen) the resulting sample buffer is stored in this array so that it can be immediately recalled.\n**/\n/**###Gibberish.callback : property\nString. Whenever Gibberish performs code generation the resulting callback is stored here.\n**/\n/**###Gibberish.out : property\nObject. The is the 'master' bus that everything eventually gets routed to if you're using the auto-generated calback. This bus is initialized in the call to Gibberish.init.\n**/\n/**###Gibberish.dirtied : property\nArray. A list of objects that need to be codegen'd\n**/\n/**###Gibberish.isDirty : property\nBooelan. Whether or codegen should be performed.\n**/\n/**###Gibberish.codeblock : property\nArray. During codegen, each ugen's codeblock is inserted into this array. Once all the ugens have codegen'd, the array is concatenated to form the callback.\n**/\n/**###Gibberish.upvalues : property\nArray. Each ugen's callback function is stored in this array; the contents of the array become upvalues to the master callback function when it is codegen'd.\n**/\n/**###Gibberish.debug : property\nBoolean. Default false. When true, the callbackString is printed to the console whenever a codegen is performed\n**/\n/**###Gibberish.memo : property\nObject. Used in the codegen process to make sure codegen for each ugen is only performed once.\n**/\n\n\nvar Gibberish = {\n  memo              : {},\n  codeblock         : [],\n  analysisCodeblock : [],\n  analysisUgens     : [],\n  dirtied           : [],\n  id                : 0,\n  isDirty           : false,  // whether or not callback needs to codegen'd\n  out               : null,   // main output bus\n  debug             : false,\n  callback          : '',\n  audioFiles        : {},\n  sequencers        : [],\n  callbackArgs      : ['input'], // names of function arguments for main audio callback\n  callbackObjects   : [],        // ugen function callbacks used in main audio callback\n  analysisCallbackArgs    : [],\n  analysisCallbackObjects : [],\n  onBlock: null,\n/**###Gibberish.createCallback : method\nPerform codegen on all dirty ugens and re-create the audio callback. This method is called automatically in the default Gibberish sample loop whenever Gibberish.isDirty is true.\n**/\n  createCallback : function() {\n    this.memo = {};\n    \n    this.codeblock.length = 0;\n    \n    this.callbackArgs.length = 0;\n    this.callbackObjects.length = 0;\n    this.analysisCallbackArgs.length = 0;\n    \n    /* generate code for dirty ugens */\n    /*for(var i = 0; i < this.dirtied.length; i++) {\n      this.dirtied[i].codegen();\n    }*/\n    this.dirtied.length = 0;\n    \n    this.codestring = '\\t'\n    \n    this.args = ['input']\n    \n    this.out.codegen()\n    \n    var codeblockStore = this.codeblock.slice(0)\n    \n    // we must push these here because the callback arguments are at the start of the string, \n    // but we have to wait to codegen the analysis ugens until after their targets have been codegen'd\n    if(this.analysisUgens.length > 0) { \n      this.analysisCodeblock.length = 0;\n      for(var i = 0; i < this.analysisUgens.length; i++) {\n        this.analysisCallbackArgs.push( this.analysisUgens[i].analysisSymbol )\n      }\n    }\n    \n    this.args = this.args.concat( this.callbackArgs )\n    \n    this.args = this.args.concat( this.analysisCallbackArgs )\n\n    /* concatenate code for all ugens */\n    //this.memo = {};\n    \n    this.codestring += codeblockStore.join('\\t') //this.codeblock.join(\"\\t\");\n    this.codestring += \"\\n\\t\";\n    \n    /* analysis codeblock */\n    if(this.analysisUgens.length > 0) {\n      this.analysisCodeblock.length = 0;\n      for(var i = 0; i < this.analysisUgens.length; i++) {\n        this.codeblock.length = 0;\n        this.analysisUgens[i].analysisCodegen();\n        /*\n        if(this.codestring !== 'undefined' ) {\n          this.codestring += this.codeblock.join(\"\");\n          this.codestring += \"\\n\\t\";\n          this.analysisCodeblock.push ( this.analysisUgens[i].analysisCodegen() );\n        }\n        */\n      }\n      this.codestring += this.analysisCodeblock.join('\\n\\t');\n      this.codestring += '\\n\\t';\n    }\n    this.codestring += 'return ' + this.out.variable +';\\n';\n    \n    this.callbackString = this.codestring;\n    if( this.debug ) console.log( this.callbackString );\n    \n    return [this.args, this.codestring];\n  },\n\n/**###Gibberish.audioProcess : method\nThe default audio callback used in Webkit browsers. This callback starts running as soon as Gibberish.init() is called.  \n  \nparam **Audio Event** : Object. The HTML5 audio event object.\n**/ \n  audioProcess : function(e){\n\t\tvar bufferL = e.outputBuffer.getChannelData(0),\n\t\t    bufferR = e.outputBuffer.getChannelData(1),\t\n\t\t    input = e.inputBuffer.getChannelData(0),\n        me = Gibberish,\n        callback = me.callback,\n        sequencers = me.sequencers,\n        out = Gibberish.out.callback,\n        objs = me.callbackObjects.slice(0),\n        callbackArgs, callbackBody, _callback, val\n\n    if( me.onBlock !== null ) me.onBlock( me.context )\n    \n    objs.unshift(0)\n        \n\t\tfor(var i = 0, _bl = e.outputBuffer.length; i < _bl; i++){\n      \n      for(var j = 0; j < sequencers.length; j++) { sequencers[j].tick(); }\n      \n      if(me.isDirty) {\n        _callback = me.createCallback();\n        try{\n          callback = me.callback = new Function( _callback[0], _callback[1] )\n        }catch( e ) {\n          console.error( \"ERROR WITH CALLBACK : \\n\\n\", _callback )\n        }\n        \n        me.isDirty = false;\n        objs = me.callbackObjects.slice(0)\n        objs.unshift(0)\n      }\n      \n      //console.log( \"CB\", callback )\n      objs[0] = input[i]\n      val = callback.apply( null, objs );\n      \n\t\t\tbufferL[i] = val[0];\n\t\t\tbufferR[i] = val[1];      \n\t\t}\n  },\n/**###Gibberish.audioProcessFirefox : method\nThe default audio callback used in Firefox. This callback starts running as soon as Gibberish.init() is called.  \n  \nparam **Sound Data** : Object. The buffer of audio data to be filled\n**/   \n  audioProcessFirefox : function(soundData) { // callback for firefox\n    var me = Gibberish,\n        callback = me.callback,\n        sequencers = me.sequencers,\n        objs = me.callbackObjects.slice(0),\n        _callback\n        \n    objs.unshift(0)\n    for (var i=0, size=soundData.length; i<size; i+=2) {\n      \n      for(var j = 0; j < sequencers.length; j++) { sequencers[j].tick(); }\n      \n      if(me.isDirty) {\n        _callback = me.createCallback();\n        \n        try {\n          callback = me.callback = new Function( _callback[0], _callback[1] )\n        }catch( e ) {\n          console.error( 'ERROR WITH CALLBACK : \\n\\n', callback )\n        }\n        me.isDirty = false;\n        objs = me.callbackObjects.slice(0)\n        objs.unshift(0)       \n      }      \n      \n\t\t\tvar val = callback.apply(null, objs);\n      \n\t\t\tsoundData[i] = val[0];\n      soundData[i+1] = val[1];\n    }\n  },\n/**###Gibberish.clear : method\nRemove all objects from Gibberish graph and perform codegen... kills all running sound and CPU usage.\n**/   \n  clear : function() {\n    this.out.inputs.length = 0;\n    this.analysisUgens.length = 0;\n    this.sequencers.length = 0;\n    \n    this.callbackArgs.length = 2\n    this.callbackObjects.length = 1\n    \n    Gibberish.dirty(this.out);\n  },\n\n/**###Gibberish.dirty : method\nTell Gibberish a ugen needs to be codegen'd and mark the entire callback as needing regeneration  \n  \nparam **Ugen** : Object. The ugen that is 'dirtied'... that has a property value changed.\n**/     \n\tdirty : function(ugen) {\n    if(typeof ugen !== 'undefined') {\n      var found = false;\n      for(var i = 0; i < this.dirtied.length; i++) {\n        if(this.dirtied[i].variable === ugen.variable) found = true;\n      }\n    \n      if(!found) {\n        this.isDirty = true;\n        this.dirtied.push(ugen);\n      }\n    }else{\n      this.isDirty = true;\n    }\n\t},\n\n/**###Gibberish.generateSymbol : method\nGenerate a unique symbol for a given ugen using its name and a unique id number.  \n  \nparam **name** : String. The name of the ugen; for example, reverb, delay etc.\n**/       \n\tgenerateSymbol : function(name) {\n\t\treturn name + \"_\" + this.id++; \n\t},\n  \n  // as taken from here: https://wiki.mozilla.org/Audio_Data_API#Standardization_Note\n  // only the number of channels is changed in the audio.mozSetup() call\n  \n/**###Gibberish.AudioDataDestination : method\nUsed to generate callback for Firefox.  \n  \nparam **sampleRate** : String. The sampleRate for the audio callback to run at. NOT THE BUFFER SIZE.  \nparam **readFn** : Function. The audio callback to use.\n**/ \n  AudioDataDestination : function(sampleRate, readFn) { // for Firefox Audio Data API\n    // Initialize the audio output.\n    var audio = new Audio();\n    audio.mozSetup(2, sampleRate);\n\n    var currentWritePosition = 0;\n    var prebufferSize = sampleRate / 2; // buffer 500ms\n    var tail = null, tailPosition;\n\n    // The function called with regular interval to populate \n    // the audio output buffer.\n    setInterval(function() {\n      var written;\n      // Check if some data was not written in previous attempts.\n      if(tail) {\n        written = audio.mozWriteAudio(tail.subarray(tailPosition));\n        currentWritePosition += written;\n        tailPosition += written;\n        if(tailPosition < tail.length) {\n          // Not all the data was written, saving the tail...\n          return; // ... and exit the function.\n        }\n        tail = null;\n      }\n\n      // Check if we need add some data to the audio output.\n      var currentPosition = audio.mozCurrentSampleOffset();\n      var available = currentPosition + prebufferSize - currentWritePosition;\n      if(available > 0) {\n        // Request some sound data from the callback function.\n        var soundData = new Float32Array(available);\n        readFn(soundData);\n\n        // Writting the data.\n        written = audio.mozWriteAudio(soundData);\n        currentPosition = audio.mozCurrentSampleOffset();\n        if(written < soundData.length) {\n          // Not all the data was written, saving the tail.\n          tail = soundData;\n          tailPosition = written;\n        }\n        currentWritePosition += written;\n      }\n    }, 100);\n  },\n/**###Gibberish.AudioDataDestination : method\nCreate a callback and start it running. Note that in iOS audio callbacks can only be created in response to user events. Thus, in iOS this method assigns an event handler to the HTML body that creates the callback as soon as the body is touched; at that point the event handler is removed. \n**/   \n  init : function() {\n    // TODO: GET A BETTER TEST FOR THIS. The problem is that browserify adds a process object... not sure how robust\n    // testing for the presence of the version property will be\n    var isNode = typeof global !== 'undefined',\n        bufferSize = typeof arguments[0] === 'undefined' ? 1024 : arguments[0], \n        audioContext,\n        start\n    \n    if( typeof webkitAudioContext !== 'undefined' ) {\n      audioContext = webkitAudioContext\n    }else if ( typeof AudioContext !== 'undefined' ) {\n      audioContext = AudioContext\n    }\n\n    // we will potentially delay start of audio until touch of screen for iOS devices\n    start = function() {\n      if( typeof audioContext !== 'undefined' ) {\n        if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {\n          window.removeEventListener('touchstart', start);\n\n          if('ontouchstart' in document.documentElement){ // required to start audio under iOS 6\n            var mySource = Gibberish.context.createBufferSource();\n            mySource.connect(Gibberish.context.destination);\n            mySource.noteOn(0);\n          }\n        }\n      }else{\n        alert('Your browser does not support javascript audio synthesis. Please download a modern web browser that is not Internet Explorer.')\n      }\n      \n      if( Gibberish.onstart ) Gibberish.onstart()\n    }\n    \n    Gibberish.context = new audioContext();\n    Gibberish.node = Gibberish.context.createScriptProcessor(bufferSize, 2, 2, Gibberish.context.sampleRate);\t\n    Gibberish.node.onaudioprocess = Gibberish.audioProcess;\n    Gibberish.node.connect(Gibberish.context.destination);\n    \n    Gibberish.out = new Gibberish.Bus2();\n    Gibberish.out.codegen(); // make sure bus is first upvalue so that clearing works correctly\n    Gibberish.dirty(Gibberish.out);\n    \n    if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {\n      window.addEventListener('touchstart', start);\n    }else{\n      start();\n    }\n    \n    return this;\n  },\n  \n/**###Gibberish.makePanner : method\nCreate and return an object that can be used to pan a stereo source.\n**/ \n  //   makePanner : function() {\n  //   var sin = Math.sin;\n  //   var cos = Math.cos;\n  //   var sqrtTwoOverTwo = Math.sqrt(2) / 2;\n  //     \n  //   var f = function(val, pan, array) {\n  //       var isObject = typeof val === 'object';\n  //       var l = isObject ? val[0] : val;\n  //       var r = isObject ? val[1] : val;\n  //           \n  //       array[0] = l * (sqrtTwoOverTwo * (cos(pan) - sin(pan)) );\n  //       array[1] = r * (sqrtTwoOverTwo * (cos(pan) + sin(pan)) );\n  //           \n  //     return array;\n  //   };\n  //         \n  //   return f;\n  // },\n  \nmakePanner : function() {\n  // thanks to grrrwaaa for this\n  // create pan curve arrays (once-only): \n\tvar panTableL = [], panTableR = [];\n\tvar sqrtTwoOverTwo = Math.sqrt(2) / 2;\n\n\tfor( var i = 0; i < 1024; i++ ) { \n\t\tvar pan = -1 + ( i / 1024 ) * 2;\n\t\tpanTableL[i] = (sqrtTwoOverTwo * (Math.cos(pan) - Math.sin(pan)) );\n\t\tpanTableR[i] = (sqrtTwoOverTwo * (Math.cos(pan) + Math.sin(pan)) );\n\t}\n\n  return function(val, pan, output) {\n    var isObject = typeof val === 'object',\n        l = isObject ? val[0] : val,\n        r = isObject ? val[1] : val,\n        _index, index, frac, index2, val1, val2;\n      \n    _index  = ((pan + 1) * 1023) / 2\n    index   = _index | 0\n    frac    = _index - index;\n    index   = index & 1023;\n    index2  = index === 1023 ? 0 : index + 1;\n    \n    val1    = panTableL[index];\n    val2    = panTableL[index2];\n    output[0] = ( val1 + ( frac * (val2 - val1) ) ) * l;\n    \n    val1    = panTableR[index];\n    val2    = panTableR[index2];\n    output[1] = ( val1 + ( frac * (val2 - val1) ) ) * r;\n    \n    return output;\n\t}\n},\n  // IMPORTANT: REMEMBER THIS IS OVERRIDDEN IN GIBBER\n  defineUgenProperty : function(key, initValue, obj) {\n    var prop = obj.properties[key] = {\n      value:  initValue,\n      binops: [],\n      parent : obj,\n      name : key,\n    };\n\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      get: function() { return prop.value },\n      set: function(val) { \n        prop.value = val;\n        Gibberish.dirty(obj);\n      },\n    });\n  },\n/**###Gibberish.polyInit : method\nFor ugens with polyphony, add metaprogramming that passes on property changes to the 'children' of the polyphonic object. Polyphonic ugens in Gibberish are just single instances that are routed into a shared bus, along with a few special methods for voice allocation etc.  \n  \nparam **Ugen** : Object. The polyphonic ugen\n**/ \n  polyInit : function(ugen) {\n    ugen.mod = ugen.polyMod;\n    ugen.removeMod = ugen.removePolyMod;\n    \n    ugen.voicesClear = function() {\n      if( ugen.children.length > 0 ) {\n        for( var i = 0; i < ugen.children.length; i++ ) {\n          ugen.children[ i ].disconnect()\n        }\n        ugen.children.length = 0\n        ugen.voiceCount = 0\n      }\n    }\n    \n    for(var key in ugen.polyProperties) {\n      (function(_key) {\n        var value = ugen.polyProperties[_key];\n        \n        Object.defineProperty(ugen, _key, {\n          configurable: true,\n          get : function() { return value; },\n          set : function(val) { \n            value = val;\n            for(var i = 0; i < ugen.children.length; i++) {\n              ugen.children[i][_key] = value;\n            }\n          },\n        });\n        \n      })(key);\n    }\n    \n    var maxVoices = ugen.maxVoices\n    Object.defineProperty( ugen, 'maxVoices', {\n      get: function() { return maxVoices },\n      set: function(v) { maxVoices = v; this.voicesClear(); this.initVoices() }\n    })\n  },\n  \n/**###Gibberish.interpolate : method\nSimiliar to makePanner, this method returns a function that can be used to linearly interpolate between to values. The resulting function takes an array and a floating point position index and returns a value.\n**/   \n\tinterpolate : function(arr, phase){\n\t\tvar\tindex\t  = phase | 0, // round down\n        index2  = index + 1 > arr.length - 1 ? 0 : index + 1;\n\t\t\t\tfrac\t  = phase - index;\n    \t\t\t\t\n    return arr[index] + frac * (arr[index2] - arr[index]);\n\t},\n  \n  pushUnique : function(item, array) {\n\t\tvar obj = item;\n\t\tvar shouldAdd = true;\n    \n\t\tfor(var j = 0; j < array.length; j++) {\n\t\t\tif(obj === array[j]) {\n\t\t\t\tshouldAdd = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n    \n\t\tif(shouldAdd) {\n\t\t\tarray.push(obj);\n\t\t}\n  },\n  \n  export : function(key, obj) {\n    for(var _key in Gibberish[key]) {\n      //console.log(\"exporting\", _key, \"from\", key);\n      obj[_key] = Gibberish[key][_key];\n    }\n  },\n\n/**###Gibberish.ugen : method\nCreates a prototype object that is used by all ugens.\n**/    \n  ugen : function() {\n    Gibberish.extend(this, {\n  \n/**#Ugen - Miscellaneous\nThe prototype object that all ugens inherit from\n**/\n/**###Ugen.processProperties : method\nUsed to assign and process arguments passed to the constructor functions of ugens.  \n  \nparam **argumentList** : Array. A list of arguments (may be a single dictionary) passed to a ugen constructor.\n**/     \n\n      processProperties : function(args){\n        if(typeof arguments[0][0] === 'object' && typeof arguments[0][0].type === 'undefined' && !Array.isArray(arguments[0][0]) && arguments[0][0].name !== 'op') {\n          var dict = arguments[0][0];\n          for(var key in dict) {\n            if(typeof dict[key] !== 'undefined') {\n              if(typeof this.properties[key] === 'object' && typeof this.properties[key].binops !== 'undefined') {\n                this.properties[key].value = dict[key];\n              }else{\n                this[key] = dict[key];\n              } \n            }\n          }\n        }else{\n          var i = 0;\n          for(var key in this.properties) {\n            if(typeof this.properties[key] === 'object' && typeof this.properties[key].binops !== 'undefined') {\n              if(typeof arguments[0][i] !== 'undefined'){\n                this.properties[key].value = arguments[0][i++];\n              }\n            }else{\n              if(typeof arguments[0][i] !== 'undefined') {\n                this.properties[key] = arguments[0][i++];\n              }\n            }\n          }\n        }\n        return this;\n      },\n      \n      valueOf: function() {\n        this.codegen()\n        //console.log( \"VALUEOF\", this.variable )\n        return this.variable\n      },\n/**###Ugen.codegen : method\nGenerates output code (as a string) used inside audio callback\n**/   \n      codegen : function() {\n        var s = '', \n            v = null,\n            initialized = false;\n        \n        if(Gibberish.memo[this.symbol]) {\n          //console.log(\"MEMO\" + this.symbol);\n          return Gibberish.memo[this.symbol];\n        }else{\n          // we generate the symbol and use it to create our codeblock, but only if the ugen doesn't already have a variable assigned. \n          // since the memo is cleared every time the callback is created, we need to check to see if this exists. \n          v = this.variable ? this.variable : Gibberish.generateSymbol('v');\n          Gibberish.memo[this.symbol] = v;\n          this.variable = v;\n        }\n\n        s += 'var ' + v + \" = \" + this.symbol + \"(\";\n\n        for(var key in this.properties) {\n          var property = this.properties[key];\n          var value = '';\n          //if(this.name === \"single_sample_delay\") { console.log( \"SSD PROP\" + key ); }\n          if( Array.isArray( property.value ) ) {\n            if(property.value.length === 0) value = 0;  // primarily for busses\n            \n            for(var i = 0; i < property.value.length; i++) {\n              var member = property.value[i];\n              if( typeof member === 'object' ) {\n            \t\tvalue += member !== null ? member.valueOf() : 'null';\n              }else{\n                if(typeof property.value === 'function') {\n                  value += property.value();\n                }else{\n                  value += property.value;\n                }\n              }\n              value += i < property.value.length - 1 ? ', ' : '';\n            }\n            \n          }else if( typeof property.value === 'object' ) {\n            if( property.value !== null) {\n              value = property.value.codegen ? property.value.valueOf() : property.value\n            }\n          }else if( property.name !== 'undefined'){\n            if(typeof property.value === 'function') {\n              value = property.value();\n            }else{\n              value = property.value;\n            }\n          }\n          \n\n          if(property.binops.length != 0) {\n            for( var k = 0; k < property.binops.length; k++) {\n              s += '(' // all leading parenthesis...\n            }\n            for(var j = 0; j < property.binops.length; j++) {\n              var op = property.binops[j],\n                  val;\n                  \n              if( typeof op.ugen === 'number') {\n                  val = op.ugen;\n              }else{\n                  val = op.ugen !== null ? op.ugen.valueOf() : 'null';\n              }\n              \n              if(op.binop === \"=\") {\n                s = s.replace(value, \"\");\n                s += val;\n              }else if(op.binop === \"++\"){\n                s += ' + Math.abs(' + val + ')';\n              }else{\n                if( j === 0) s+= value\n                s += \" \" + op.binop + \" \" + val + \")\";\n              }\n              \n            }\n          }else{\n            s += value\n          }\n\n          s += \", \";\n        }\n        \n        if(s.charAt(s.length - 1) === \" \")\n          s = s.slice(0, -2); // remove trailing spaces\n      \n        s += \");\\n\";\n        \n        this.codeblock = s;\n        \n        if( Gibberish.codeblock.indexOf( this.codeblock ) === -1 ) Gibberish.codeblock.push( this.codeblock )\n        if( Gibberish.callbackArgs.indexOf( this.symbol ) === -1 && this.name !== 'op') { Gibberish.callbackArgs.push( this.symbol ) }\n        if( Gibberish.callbackObjects.indexOf( this.callback ) === -1 && this.name !== 'op' ) { Gibberish.callbackObjects.push( this.callback ) }\n        \n        this.dirty = false;        \n        \n        return v;\n      },\n\n/**###Ugen.defineUgenProperty : method\nCreates getters and setters for ugen properties that automatically dirty the ugen whenever the property value is changed.  \n  \nparam **key** : String. The name of a property to add getter / setters for.  \nparam **value** : Any. The initival value to set the property to\n**/       \n      \n/**###Ugen.init : method\nInitialize ugen by calling defineUgenProperty for every key in the ugen's properties dictionary, generating a unique id for the ugen and various other small tasks.\n**/             \n      init : function() {\n        if(!this.initalized) {\n          this.symbol = Gibberish.generateSymbol(this.name);\n          this.codeblock = null;\n          this.variable = null;\n        }\n        \n        if(typeof this.properties === 'undefined') {\n          this.properties = {};\n        }\n        \n        if(!this.initialized) {\n          this.destinations = [];\n          for(var key in this.properties) {\n            Gibberish.defineUgenProperty(key, this.properties[key], this);\n          }\n        }\n        \n        if(arguments.length > 0 && typeof arguments[0][0] === 'object' && arguments[0][0].type === 'undefined') {\n          var options = arguments[0][0];\n          for(var key in options) {\n            this[key] = options[key];\n          }\n        }\n                        \n        this.initialized = true;\n        \n        return this;\n      },\n/**###Ugen.mod : method\nModulate a property of a ugen on a per-sample basis.  \n  \nparam **key** : String. The name of the property to modulate  \nparam **value** : Any. The object or number value to modulate the property with  \nparam **op** : String. Default \"+\". The operation to perform. Can be +,-,*,/,= or ++. ++ adds and returns the absolute value.\n**/            \n      mod : function(name, value, op) {\n        var property = this.properties[ name ];\n        var mod = { ugen:value, binop:op };\n       \tproperty.binops.push( mod );\n        \n        Gibberish.dirty( this );\n      },\n/**###Ugen.removeMod : method\nRemove a modulation from a ugen.  \n  \nparam **key** : String. The name of the property to remove the modulation from  \nparam **arg** : Number or Object. Optional. This determines which modulation to remove if more than one are assigned to the property. If this argument is undefined, all modulations are removed. If the argument is a number, the number represents a modulation in the order that they were applied (an array index). If the argument is an object, it removes a modulation that\nis using a matching object as the modulator.\n**/                  \n      removeMod : function(name, arg) {\n        if(typeof arg === 'undefined' ) {\n          this.properties[name].binops.length = 0;\n        }else if(typeof arg === 'number') {\n          this.properties[name].binops.splice(arg, 1);\n        }else if(typeof arg === 'object') {\n          for(var i = 0, j = this.properties[name].binops.length; i < j; i++) {\n            if(this.properties[name].binops[i].ugen === arg) {\n              this.properties[name].binops.splice(i, 1);\n            }\n          }\n        };\n        \n        Gibberish.dirty( this );\n      },\n\n/**###Ugen.polyMod : method\nApplies a modulation to all children of a polyphonic ugen  \n  \nparam **key** : String. The name of the property to modulate  \nparam **value** : Any. The object or number value to modulate the property with  \nparam **op** : String. Default \"+\". The operation to perform. Can be +,-,*,/,= or ++. ++ adds and returns the absolute value.\n**/       \n  \t\tpolyMod : function(name, modulator, type) {\n  \t\t\tfor(var i = 0; i < this.children.length; i++) {\n  \t\t\t\tthis.children[i].mod(name, modulator, type);\n  \t\t\t}\n  \t\t\tGibberish.dirty(this);\n  \t\t},\n\n/**###Ugen.removePolyMod : method\nRemoves a modulation from all children of a polyphonic ugen. The arguments  \n  \nparam **arg** : Number or Object. Optional. This determines which modulation to remove if more than one are assigned to the property. If this argument is undefined, all modulations are removed. If the argument is a number, the number represents a modulation in the order that they were applied (an array index). If the argument is an object, it removes a modulation that\nis using a matching object as the modulator.\n**/       \n  \t\tremovePolyMod : function() {\n  \t\t\tvar args = Array.prototype.slice.call(arguments, 0);\n        \n  \t\t\tif(arguments[0] !== \"amp\" && arguments[0] !== \"pan\") {\n  \t\t\t\tfor(var i = 0; i < this.children.length; i++) {\n  \t\t\t\t\tthis.children[i].removeMod.apply(this.children[i], args);\n  \t\t\t\t}\n  \t\t\t}else{\n  \t\t\t\tthis.removeMod.apply(this, args);\n  \t\t\t}\n        \n  \t\t\tGibberish.dirty(this);\n  \t\t},\n      \n      smooth : function(property, amount) {\n        var op = new Gibberish.OnePole();\n        this.mod(property, op, \"=\");\n      },\n/**###Ugen.connect : method\nConnect the output of a ugen to a bus.  \n  \nparam **bus** : Bus ugen. Optional. The bus to connect the ugen to. If no argument is passed the ugen is connect to Gibberish.out. Gibberish.out is automatically created when Gibberish.init() is called and can be thought of as the master stereo output for Gibberish.\n**/      \n      connect : function(bus, position) {\n        if(typeof bus === 'undefined') bus = Gibberish.out;\n        \n        if(this.destinations.indexOf(bus) === -1 ){\n          bus.addConnection( this, 1, position );\n          this.destinations.push( bus );\n        }\n        return this;\n      },\n/**###Ugen.send : method\nSend an arbitrary amount of output to a bus  \n  \nparam **bus** : Bus ugen. The bus to send the ugen to.  \nparam **amount** : Float. The amount of signal to send to the bus. \n**/      \n      send : function(bus, amount) {\n        if(this.destinations.indexOf(bus) === -1 ){\n          bus.addConnection( this, amount );\n          this.destinations.push( bus );\n        }else{\n          bus.adjustSendAmount(this, amount);\n        }\n        return this;\n      },\n/**###Ugen.disconnect : method\nDisconnect a ugen from a bus (or all busses). This stops all audio and signal processing for the ugen.  \n  \nparam **bus** : Bus ugen. Optional. The bus to disconnect the ugen from. If this argument is undefined the ugen will be disconnected from all busses.\n**/      \n      disconnect : function(bus, tempDisconnect ) { // tempDisconnect is used to do a short disconnect and reconnect\n        var idx\n        \n        if( !tempDisconnect ) {\n          /*if( this.children ) {\n            for(var i = 0; i < this.children.length; i++) {\n              this.children[i].disconnect( this )\n            }\n          }else if( typeof this.input === 'object' ) {\n            this.input.disconnect( null, tempDisconnect )\n          }*/\n          \n          /*var idx = Gibberish.callbackArgs.indexOf( this.symbol )\n          Gibberish.callbackArgs.splice(idx, 1)\n        \n          idx = Gibberish.callbackObjects.indexOf( this.callback )        \n          Gibberish.callbackObjects.splice(idx, 1)*/\n        }\n        \n        if( !bus ) {\n          for(var i = 0; i < this.destinations.length; i++) {\n            this.destinations[i].removeConnection( this );\n          }\n          this.destinations = [];\n        }else{\n          idx = this.destinations.indexOf(bus);\n          if(idx > -1) {\n            this.destinations.splice(idx, 1);\n          }\n          bus.removeConnection( this );\n        }\n        \n        Gibberish.dirty( this )\n        return this;\n      },\n    });\n  },\n};\n\n\nArray2 = function() { \n  this.length = 0;\n};\n\nArray2.prototype = [];\n\t\nArray2.prototype.remove = function(arg, searchDeep) { // searchDeep when true removes -all- matches, when false returns first one found.\n\tsearchDeep = typeof searchDeep === 'undefined' ? true : searchDeep;\n\tif(typeof arg === \"undefined\") { // clear all\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tdelete this[i];\n\t\t}\n\t\tthis.length = 0;\n\t}else if(typeof arg === \"number\") {\n\t\tthis.splice(arg,1);\n\t}else if(typeof arg === \"string\"){ // find named member and remove\n\t\tvar removeMe = [];\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar member = this[i];\n\t\t\tif(member.type === arg || member.name === arg) {\n\t\t\t\tif(!searchDeep) {\n\t\t\t\t\tthis.splice(i,1);\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tremoveMe.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(var i = 0; i < removeMe.length; i++) {\n\t\t\tthis.splice( removeMe[i], 1);\n\t\t}\n\t}else if(typeof arg === \"object\") {\n\t\tvar idx = this.indexOf(arg);\n\t\twhile(idx > -1) {\n\t\t\tthis.splice(idx,1);\n\t\t\tidx = this.indexOf(arg);\n\t\t}\n\t}\n\tif(this.parent) Gibberish.dirty(this.parent);\n};\n\t\nArray2.prototype.get = function(arg) {\n\tif(typeof arg === \"number\") {\n\t\treturn this[arg];\n\t}else if(typeof arg === \"string\"){ // find named member and remove\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar member = this[i];\n\n\t\t\tif(member.name === arg) {\n\t\t\t\treturn member;\n\t\t\t}\n\t\t}\n\t}else if(typeof arg === \"object\") {\n\t\tvar idx = this.indexOf(arg);\n\t\tif(idx > -1) {\n\t\t\treturn this[idx];\n\t\t}\n\t}\n\treturn null;\n};\n\t\n\nArray2.prototype.replace = function(oldObj, newObj) {\n\tnewObj.parent = this;\n  newObj.input = oldObj.input;\n  \n\tif(typeof oldObj != \"number\") {\n\t\tvar idx = this.indexOf(oldObj);\n\t\tif(idx > -1) {\n\t\t\tthis.splice(idx, 1, newObj);\n\t\t}\n\t}else{\n\t\tthis.splice(oldObj, 1, newObj);\n\t}\n\tif(this.parent) Gibberish.dirty(this.parent);\n};\n\nArray2.prototype.insert = function(v, pos) {\n\tv.parent = this;\n  this.input = this.parent;\n  \n\tif(Array.isArray(v)) {\n\t\tfor(var i = 0; i < v.length; i++) {\n\t\t\tthis.splice(pos + i, 0, v[i]);\n\t\t}\n\t}else{\n\t\tthis.splice(pos,0,v);\n\t}\n\tif(this.parent) Gibberish.dirty(this.parent);\n};\n\nArray2.prototype.add = function() {\n\tfor(var i = 0; i < arguments.length; i++) {\n\t\targuments[i].parent = this;\n    arguments[i].input = this.parent;\n\t\t//console.log(this.parent, this.parent.channels);\n\t\t//if(typeof this.parent.channels === \"number\") {\n\t\t\t//console.log(\"CHANGING CHANNELS\");\n\t\t\t//arguments[i].channels = this.parent.channels;\n    //}\n\t\tthis.push(arguments[i]);\n\t}\n\t//console.log(\"ADDING ::: this.parent = \", this.parent)\n\tif(this.parent) {  \n    console.log(\"DIRTYING\");\n  \tGibberish.dirty(this.parent);\n  }\n\t\t\n};\n\t\nvar rnd = Math.random;\nGibberish.rndf = function(min, max, number, canRepeat) {\n  canRepeat = typeof canRepeat === \"undefined\" ? true : canRepeat;\n\tif(typeof number === \"undefined\" && typeof min != \"object\") {\n\t\tif(arguments.length == 1) {\n\t\t\tmax = arguments[0]; min = 0;\n\t\t}else if(arguments.length == 2) {\n\t\t\tmin = arguments[0];\n\t\t\tmax = arguments[1];\n\t\t}else{\n\t\t\tmin = 0;\n\t\t\tmax = 1;\n\t\t}\n\n\t\tvar diff = max - min,\n\t\t    r = Math.random(),\n\t\t    rr = diff * r\n\t\n\t\treturn min + rr;\n\t}else{\n\t\tvar output = [];\n\t\tvar tmp = [];\n\t\tif(typeof number === \"undefined\") {\n\t\t\tnumber = max || min.length;\n\t\t}\n\t\t\n\t\tfor(var i = 0; i < number; i++) {\n\t\t\tvar num;\n\t\t\tif(typeof arguments[0] === \"object\") {\n\t\t\t\tnum = arguments[0][rndi(0, arguments[0].length - 1)];\n\t\t\t}else{\n\t\t\t\tif(canRepeat) {\n\t\t\t\t\tnum = Gibberish.rndf(min, max);\n\t\t\t\t}else{\n          num = Gibberish.rndf(min, max);\n          while(tmp.indexOf(num) > -1) {\n            num = Gibberish.rndf(min, max);\n          }\n\t\t\t\t\ttmp.push(num);\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput.push(num);\n\t\t}\n\t\treturn output;\n\t}\n};\n  \nGibberish.Rndf = function() {\n  var _min, _max, quantity, random = Math.random, canRepeat;\n    \n  if(arguments.length === 0) {\n    _min = 0; _max = 1;\n  }else if(arguments.length === 1) {\n    _max = arguments[0]; _min = 0;\n  }else if(arguments.length === 2) {\n    _min = arguments[0]; _max = arguments[1];\n  }else if(arguments.length === 3) {\n    _min = arguments[0]; _max = arguments[1]; quantity = arguments[2];\n  }else{\n    _min = arguments[0]; _max = arguments[1]; quantity = arguments[2]; canRepeat = arguments[3];\n  }    \n  \n  return function() {\n    var value, min, max, range;\n    \n    min = typeof _min === 'function' ? _min() : _min\n    max = typeof _max === 'function' ? _max() : _max\n      \n    if( typeof quantity === 'undefined') {\n      value = Gibberish.rndf( min, max )\n    }else{\n      value = Gibberish.rndf( min, max, quantity, canRepeat )\n    }\n    \n    return value;\n  }\n};\n\nGibberish.rndi = function( min, max, number, canRepeat ) {\n  var range;\n    \n  if(arguments.length === 0) {\n    min = 0; max = 1;\n  }else if(arguments.length === 1) {\n    max = arguments[0]; min = 0;\n  }else if( arguments.length === 2 ){\n    min = arguments[0]; max = arguments[1];\n  }else{\n    min = arguments[0]; max = arguments[1]; number = arguments[2]; canRepeat = arguments[3];\n  }    \n  \n  range = max - min\n  if( range < number ) canRepeat = true\n  \n  if( typeof number === 'undefined' ) {\n    range = max - min\n    return Math.round( min + Math.random() * range );\n  }else{\n\t\tvar output = [];\n\t\tvar tmp = [];\n\t\t\n\t\tfor(var i = 0; i < number; i++) {\n\t\t\tvar num;\n\t\t\tif(canRepeat) {\n\t\t\t\tnum = Gibberish.rndi(min, max);\n\t\t\t}else{\n\t\t\t\tnum = Gibberish.rndi(min, max);\n\t\t\t\twhile(tmp.indexOf(num) > -1) {\n\t\t\t\t\tnum = Gibberish.rndi(min, max);\n\t\t\t\t}\n\t\t\t\ttmp.push(num);\n\t\t\t}\n\t\t\toutput.push(num);\n\t\t}\n\t\treturn output;\n  }\n};\n\nGibberish.Rndi = function() {\n  var _min, _max, quantity, random = Math.random, round = Math.round, canRepeat, range;\n    \n  if(arguments.length === 0) {\n    _min = 0; _max = 1;\n  }else if(arguments.length === 1) {\n    _max = arguments[0]; _min = 0;\n  }else if(arguments.length === 2) {\n    _min = arguments[0]; _max = arguments[1];\n  }else if(arguments.length === 3) {\n    _min = arguments[0]; _max = arguments[1]; quantity = arguments[2];\n  }else{\n    _min = arguments[0]; _max = arguments[1]; quantity = arguments[2]; canRepeat = arguments[3];\n  }  \n  \n  range = _max - _min\n  if( typeof quantity === 'number' && range < quantity ) canRepeat = true\n  \n  return function() {\n    var value, min, max, range;\n    \n    min = typeof _min === 'function' ? _min() : _min\n    max = typeof _max === 'function' ? _max() : _max\n    \n    if( typeof quantity === 'undefined') {\n      value = Gibberish.rndi( min, max )\n    }else{\n      value = Gibberish.rndi( min, max, quantity, canRepeat )\n    }\n    \n    return value;\n  }\n};\n\nGibberish.extend = function(destination, source) {\n    for (var property in source) {\n\t\t\tvar keys = property.split(\".\");\n\t\t\tif(source[property] instanceof Array && source[property].length < 100) { // don't copy large array buffers\n\t\t    destination[property] = source[property].slice(0);\n\t\t\t\tif(property === \"fx\") {\n\t\t\t\t\tdestination[property].parent = source[property].parent;\n\t\t\t\t}\n      }else if (typeof source[property] === \"object\" && source[property] !== null && !(source[property] instanceof Float32Array) ) {\n          destination[property] = destination[property] || {};\n          arguments.callee(destination[property], source[property]);\n      } else {\n          destination[property] = source[property];\n      }\n    }\n    return destination;\n};\n\t\nFunction.prototype.clone=function(){\n    return eval('['+this.toString()+']')[0];\n};\n\nString.prototype.format = function(i, safe, arg) {\n    function format() {\n        var str = this,\n            len = arguments.length + 1;\n\n        for (i = 0; i < len; arg = arguments[i++]) {\n            safe = arg; //typeof arg === 'object' ? JSON.stringify(arg) : arg;\n            str = str.replace(RegExp('\\\\{' + (i - 1) + '\\\\}', 'g'), safe);\n        }\n        return str;\n    }\n\n    format.native = String.prototype.format;\n\n    return format;\n}();\n\nGibberish.future = function(func, time) { \n  var seq = new Gibberish.Sequencer({\n    values:[\n      function(){},\n      function() {\n        func();\n        seq.stop();\n        seq.disconnect();\n      }\n    ],\n    durations:[ time ]\n  }).start()\n  \n  seq.cancel = function() {\n    seq.stop();\n    seq.disconnect();\n  }\n  \n  return seq\n}\nGibberish.Proxy = function() {\n  var value = 0;\n      \n\tGibberish.extend(this, {\n  \tname: 'proxy',\n    type: 'effect',\n    \n    properties : {},\n    \n    callback : function() {\n      return value;\n    },\n  }).init();\n  \n  this.input = arguments[0];\n  \n  value = this.input.parent[ this.input.name ];\n  delete this.input.parent[ this.input.name ];\n    \n  this.input.parent.properties[ this.input.name ].value = this;\n  \n  Object.defineProperty( this.input.parent, this.input.name, {\n    get : function(){ return value; },\n    set : function(_value) { value = _value; }\n  });\n  Gibberish.dirty(this.input.parent);\n};\nGibberish.Proxy.prototype = new Gibberish.ugen();\n\nGibberish.Proxy2 = function() {\n  var input = arguments[0],\n      name = arguments[1],\n      phase = 0\n      \n\tGibberish.extend( this, {\n  \tname: 'proxy2',\n    type: 'effect',\n    \n    properties : { },\n    \n    callback : function() {\n      var v = input[ name ]\n      // if( phase++ % 44100 === 0 ) console.log( v, input, name)\n      return Array.isArray( v ) ? ( v[0] + v[1] + v[2] ) / 3 : v\n    },\n  }).init();\n  \n  this.getInput = function() { return input }\n  this.setInput = function( v ) { input = v }\n  this.getName = function() { return name }\n  this.setName = function( v ) { name = v }\n};\nGibberish.Proxy2.prototype = new Gibberish.ugen();\n\nGibberish.Proxy3 = function() {\n  var input = arguments[0],\n      name = arguments[1],\n      phase = 0\n      \n\tGibberish.extend( this, {\n  \tname: 'proxy3',\n    type: 'effect',\n    \n    properties : { },\n    \n    callback : function() {\n      var v = input[ name ]\n      //if( phase++ % 44100 === 0 ) console.log( v, input, name)\n      return v || 0\n    },\n  })\n  \n  this.init();\n  \n  this.codegen = function() {\n    // if(Gibberish.memo[this.symbol]) {\n    //   return Gibberish.memo[this.symbol];\n    // }\n    \n    console.log(\" CALLED \")\n    if( ! this.variable ) this.variable = Gibberish.generateSymbol('v');\n    Gibberish.callbackArgs.push( this.symbol )\n    Gibberish.callbackObjects.push( this.callback )\n\n    this.codeblock = \"var \" + this.variable + \" = \" + this.symbol + \"(\" + input.properties[ name ].codegen() + \");\\n\"\n  }\n  \n};\nGibberish.Proxy3.prototype = new Gibberish.ugen();\nGibberish.oscillator = function() {\n  this.type = 'oscillator';\n  \n  this.oscillatorInit = function() {\n    this.fx = new Array2; \n    this.fx.parent = this;\n    \n    return this;\n  }\n};\nGibberish.oscillator.prototype = new Gibberish.ugen();\nGibberish._oscillator = new Gibberish.oscillator();\n\n/**#Gibberish.Table - Oscillator\nAn wavetable oscillator.\n\n## Example Usage##\n`// fill the wavetable with random samples\nGibberish.init();  \na = new Gibberish.Table();  \nvar t = []  \nfor( var i = 0; i < 1024; i++ ) { t[ i ] = Gibberish.rndf(-1,1) }  \na.setTable( t )  \na.connect()  \n`\n- - - -\n**/\n/**###Gibberish.Table.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Table.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n\nGibberish.Wavetable = function() {\n  var phase = 0,\n      table = null,\n      tableFreq = Gibberish.context.sampleRate / 1024,\n      signHistory = 0,\n      flip = 0;\n  \n  this.properties = {\n    frequency : 440,\n    amp : .25,\n    sync: 0\n  };\n  \n/**###Gibberish.Wavetable.setTable : method  \nAssign an array representing one cycle of a waveform to use.  \n\nparam **table** Float32Array. Assign an array to be used as the wavetable.\n**/     \n  this.getTable = function() { return table; }\n  this.setTable = function(_table) { table = _table; tableFreq = Gibberish.context.sampleRate / table.length }\n  \n  this.getTableFreq = function() { return tableFreq }\n  this.setTableFreq = function( v ) { tableFreq = v;  }  \n  \n  this.getPhase = function()  { return phase }\n  this.setPhase = function(v) { phase = v }\n\n/**###Gibberish.Wavetable.callback : method  \nReturns a single sample of output.  \n\nparam **frequency** Number. The frequency to be used to calculate output.  \nparam **amp** Number. The amplitude to be used to calculate output.  \n**/   \n  this.callback = function(frequency, amp, sync) { \n    var index, frac, index2, val1, val2, sign;\n            \n    phase += frequency / tableFreq;\n    while(phase >= 1024) phase -= 1024;  \n    \n    index   = phase | 0;\n    frac    = phase - index;\n    index   = index & 1023;\n    index2  = index === 1023 ? 0 : index + 1;\n    val1    = table[index];\n    val2    = table[index2];\n    \n    // sign = typeof sync == 'number' ? sync ? sync < 0 ? -1 : 1 : isNaN(sync) ? NaN : 0 : NaN;\n    // if( sign !== signHistory && sign !== 0) {\n    //   flip++\n    //   \n    //   if( flip === 2 ){\n    //     phase = 0\n    //     flip = 0\n    //   }\n    //   //console.log( \"FLIP\", sign, signHistory, count, sync )\n    // }\n    // \n    // if( sign !== 0 ) signHistory = sign\n    \n    return ( val1 + ( frac * (val2 - val1) ) ) * amp;\n  }\n}\nGibberish.Wavetable.prototype = Gibberish._oscillator;\n\nGibberish.Table = function( table ) {\n  this.__proto__ = new Gibberish.Wavetable();\n  \n  this.name = 'table';\n  \n  var pi_2 = Math.PI * 2\n  \n  if( typeof table === 'undefined' ) { \n    table = new Float32Array(1024);\n    for(var i = 1024; i--;) { table[i] = Math.sin( (i / 1024) * pi_2); }\n  }\n  \n  this.setTable( table );\n\n  this.init();\n  this.oscillatorInit();\n  //this.processProperties( arguments );\n}\n\nGibberish.asmSine = function (stdlib, foreign, heap) {\n    \"use asm\";\n\n    var sin = stdlib.Math.sin;\n    var phase = 0.0;\n    var out = new stdlib.Float32Array(heap);\n    var floor = stdlib.Math.floor;\n    var tableFreq = 0.0;\n    \n    function init() {\n      var i = 1024;\n      var j = 1024.0;\n      var test = 0.0;\n      for (;  i = (i - 1) | 0; ) {\n        j = j - 1.0;\n        out[i >> 2] = +(sin( +(j / 1024.0) * 6.2848));\n      }  \n      tableFreq = 44100.0 / 1024.0;\n    }\n    \n    function gen(freq, amp, sr) {\n      freq = +freq;\n      amp = +amp;\n      sr = +sr;\n      \n      var index = 0.0,\n          index1 = 0,\n          index2 = 0,\n          frac = 0.0,\n          val1 = 0.0,\n          val2 = 0.0;\n      \n      phase = +(phase + freq / tableFreq);\n      if(phase >= 1024.0) phase = +(phase - 1024.0);\n          \n      index = +floor(phase);\n      frac = phase - index;\n      \n      index1 = (~~index);\n      if((index1 | 0) == (1024 | 0)) {\n        index2 = 0\n      } else { \n        index2 = (index1 + 1) | 0;\n      }\n      \n      val1 = +out[ index1 >> 2 ];\n      val2 = +out[ index2 >> 2 ];\n          \n      return +((val1 + (frac * (val2 - val1))) * amp);\n    }\n    \n    function get(idx) {\n      idx = idx|0;\n      return +out[idx >> 2];\n    }\n\n    return {\n      init:init,\n      gen: gen,\n      get: get,\n    }\n};\n\n/*\n    phase += frequency / tableFreq;\n    while(phase >= 1024) phase -= 1024;  \n    \n    index   = phase | 0;\n    frac    = phase - index;\n    index   = index & 1023;\n    index2  = index === 1023 ? 0 : index + 1;\n    val1    = table[index];\n    val2    = table[index2];\n        \n    return ( val1 + ( frac * (val2 - val1) ) ) * amp;\n*/\n\n\n\n\n\n/*function gen (freq, amp, sr) {\n    freq = +freq;\n    amp  = +amp;\n    sr = +sr;\n    \n    phase = +(phase + +(+(freq / sr) * 3.14159 * 2.0));\n    \n    return +(+sin(phase) * amp);\n}*/\n//var pi_2 = (3.14159 * 2.0);\n\n\nGibberish.asmSine2 = function () {    \n    this.properties = { frequency:440.0, amp:.5, sr: Gibberish.context.sampleRate }\n    this.name = 'sine'\n    var buf = new ArrayBuffer(4096);\n    var asm = Gibberish.asmSine(window, null, buf);\n    asm.init();\n    \n    this.getTable = function() { return buf; }\n    this.get = asm.get;\n    this.callback = asm.gen;\n    this.init();\n    this.oscillatorInit();\n    this.processProperties( arguments );\n    \n    return  this;\n}\nGibberish.asmSine2.prototype = Gibberish._oscillator;\n/**#Gibberish.Sine - Oscillator\nA sinewave calculated on a per-sample basis.\n\n## Example Usage##\n`// make a sine wave  \nGibberish.init();  \na = new Gibberish.Sine().connect();`\n- - - -\n**/\n/**###Gibberish.Sine.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Sine.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n\nGibberish.Sine = function() {\n  this.__proto__ = new Gibberish.Wavetable();\n  \n  this.name = 'sine';\n  \n  var pi_2 = Math.PI * 2, \n      table = new Float32Array(1024);\n      \n  for(var i = 1024; i--;) { table[i] = Math.sin( (i / 1024) * pi_2); }\n  \n  this.setTable( table );\n\n  this.init( arguments );\n  this.oscillatorInit();\n  this.processProperties( arguments );\n};\n\n/**#Gibberish.Sine2 - Oscillator\nA sinewave calculated on a per-sample basis that can be panned.\n\n## Example Usage##\n`// make a sine wave  \nGibberish.init();  \na = new Gibberish.Sine2(880, .5, -.25).connect();`\n- - - -\n**/\n/**###Gibberish.Sine2.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Sine2.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n/**###Gibberish.Sine2.pan : property  \nNumber. -1..1. The position of the sinewave in the stereo spectrum\n**/\nGibberish.Sine2 = function() {\n  this.__proto__ = new Gibberish.Sine();\n  this.name = \"sine2\";\n    \n  var sine = this.__proto__.callback,\n      panner = Gibberish.makePanner(),\n      output = [0,0];\n\n/**###Gibberish.Sine2.callback : method  \nReturns a stereo sample of output as an array.  \n  \nparam **frequency** Number. The frequency to be used to calculate output.  \nparam **amp** Number. The amplitude to be used to calculate output.  \nparam **pan** Number. The position in the stereo spectrum of the signal.\n**/  \n  this.callback = function(frequency, amp, pan) {\n    var out = sine(frequency, amp);\n    output = panner(out, pan, output);\n    return output;\n  }\n\n  this.init();\n  this.oscillatorInit();\n  Gibberish.defineUgenProperty('pan', 0, this);\n  this.processProperties(arguments);  \n};\n\nGibberish.Square = function() {\n  this.__proto__ = new Gibberish.Wavetable();\n  \n  this.name = 'square';\n  \n  var pi_2 = Math.PI * 2, \n      table = new Float32Array(1024);\n      \n  for(var i = 1024; i--;) { \n    table[i] = i / 1024 > .5 ? 1 : -1;\n  }\n  \n  this.setTable( table );\n\n  this.init( arguments );\n  this.oscillatorInit();\n  this.processProperties( arguments );\n};\n\n/**#Gibberish.Saw - Oscillator\nA non-bandlimited saw wave calculated on a per-sample basis.\n\n## Example Usage##\n`// make a saw wave  \nGibberish.init();  \na = new Gibberish.Saw(330, .4).connect();`\n- - - -\n**/\n/**###Gibberish.Saw.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Saw.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\nGibberish.Saw = function() {\n  this.__proto__ = new Gibberish.Wavetable();\n  \n  this.name = 'saw';\n  \n  var table = new Float32Array(1024);\n      \n  for(var i = 1024; i--;) { table[i] = (((i / 1024) / 2 + 0.25) % 0.5 - 0.25) * 4; }\n  \n  this.setTable( table );\n\n  this.init( arguments );\n  this.oscillatorInit();\n  this.processProperties( arguments );\n};\n\n/**#Gibberish.Saw2 - Oscillator\nA stereo, non-bandlimited saw wave calculated on a per-sample basis.\n\n## Example Usage##\n`// make a saw wave  \nGibberish.init();  \na = new Gibberish.Saw2(330, .4).connect();`\n- - - -\n**/\n/**###Gibberish.Saw.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Saw.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\nGibberish.Saw2 = function() {\n  this.__proto__ = new Gibberish.Saw();\n  this.name = \"saw2\";\n  \n  var saw = this.__proto__.callback,\n      panner = Gibberish.makePanner(),\n      output = [0,0];\n\n/**###Gibberish.Saw2.callback : method  \nReturns a stereo sample of output as an array.  \n  \nparam **frequency** Number. The frequency to be used to calculate output.  \nparam **amp** Number. The amplitude to be used to calculate output.  \nparam **pan** Number. The position in the stereo spectrum of the signal.\n**/    \n  this.callback = function(frequency, amp, pan) {\n    var out = saw(frequency, amp);\n    output = panner(out, pan, output);\n    return output;\n  };\n\n  this.init();\n  Gibberish.defineUgenProperty('pan', 0, this);\n  \n};\n\n/**#Gibberish.Triangle - Oscillator\nA triangle calculated on a per-sample basis.\n\n## Example Usage##\n`// make a triangle wave  \nGibberish.init();  \na = new Gibberish.Triangle({frequency:570, amp:.35}).connect();`\n- - - -\n**/\n/**###Gibberish.Triangle.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Triangle.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n\nGibberish.Triangle = function() {\n  this.__proto__ = new Gibberish.Wavetable();\n  \n  this.name = 'triangle';\n  \n  var table = new Float32Array(1024),\n      abs = Math.abs;\n      \n  for(var i = 1024; i--;) { table[i] = 1 - 4 * abs(( (i / 1024) + 0.25) % 1 - 0.5); }\n  \n  this.setTable( table );\n\n  this.init( arguments );\n  this.oscillatorInit();\n  this.processProperties( arguments );\n};\n\n/**#Gibberish.Triangle2 - Oscillator\nA triangle calculated on a per-sample basis that can be panned.\n\n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.Triangle2(880, .5, -.25).connect();`\n- - - -\n**/\n/**###Gibberish.Triangle2.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Triangle2.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n/**###Gibberish.Triangle2.pan : property  \nNumber. -1..1. The position of the triangle wave in the stereo spectrum\n**/\n \nGibberish.Triangle2 = function() {\n  this.__proto__ = new Gibberish.Triangle();\n  this.name = \"triangle2\";\n    \n  var triangle = this.__proto__.callback,\n      panner = Gibberish.makePanner(),\n      output = [0,0];\n\n/**###Gibberish.Triangle2.callback : method  \nReturns a stereo sample of output as an array.  \n  \nparam **frequency** Number. The frequency to be used to calculate output.  \nparam **amp** Number. The amplitude to be used to calculate output.  \nparam **pan** Number. The position in the stereo spectrum of the signal.\n**/    \n  this.callback = function(frequency, amp, pan) {\n    var out = triangle(frequency, amp);\n    return panner(out, pan, output);\n  };\n\n  this.init();\n  this.oscillatorInit();\n  Gibberish.defineUgenProperty('pan', 0, this);\n  this.processProperties(arguments);\n};\n\n/**#Gibberish.Saw3 - Oscillator\nA bandlimited saw wave created using FM feedback, see http://scp.web.elte.hu/papers/synthesis1.pdf.  \n  \n## Example Usage##\n`// make a saw wave  \nGibberish.init();  \na = new Gibberish.Saw3(330, .4).connect();`\n- - - -\n**/\n/**###Gibberish.Saw3.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.Saw3.amp : property  \nNumber. A linear value specifying relative ampltiude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n\nGibberish.Saw3 = function() {\n  var osc = 0,\n      phase = 0,\n      a0 = 2.5,\n      a1 = -1.5,\n      history = 0,\n      sin = Math.sin,\n      scale = 11;\n      pi_2 = Math.PI * 2,\n      flip = 0,\n      signHistory = 0,\n      ignore = false,\n      sr = Gibberish.context.sampleRate;\n      \n  Gibberish.extend(this, {\n    name: 'saw',\n    properties : {\n      frequency: 440,\n      amp: .15,\n      sync:0,\n      sr: Gibberish.context.sampleRate,\n    },\n/**###Gibberish.Saw3.callback : method  \nReturns a single sample of output.  \n  \nparam **frequency** Number. The frequency to be used to calculate output.  \nparam **amp** Number. The amplitude to be used to calculate output.  \n**/    \n    callback : function(frequency, amp, sync) {\n      var w = frequency / sr,\n          n = .5 - w,\n          scaling = scale * n * n * n * n,\n          DC = .376 - w * .752,\n          norm = 1 - 2 * w,\n          out = 0,\n          sign;\n          \n      phase += w;\n      phase -= phase > 1 ? 2 : 0;\n      \n      osc = (osc + sin(pi_2 * (phase + osc * scaling))) * .5;\n      out = a0 * osc + a1 * history;\n      history = osc;\n      out += DC;\n      out *= norm;\n\n      // sign = typeof sync == 'number' ? sync ? sync < 0 ? -1 : 1 : isNaN(sync) ? NaN : 0 : NaN;\n      // if( sign !== signHistory && sign !== 0) {\n      //   flip++\n      //   \n      //   if( flip === 2 ){\n      //     phase = 0\n      //     flip = 0\n      //   }\n      //   //console.log( \"FLIP\", sign, signHistory, count, sync )\n      // }\n      // if( sign !== 0 ) signHistory = sign\n      \n      return out * amp;\n    }\n  });\n  \n  /*\n    .1 : 1 1\n    0  : 0 1   // ignored\n  -.1  : -1 1  // flip\n  -.2  : -1 -1 \n  */\n  \n  Object.defineProperty(this, 'scale', {\n    get : function() { return scale; },\n    set : function(val) { scale = val; }\n  });\n  \n  this.init();\n  this.oscillatorInit();\n  this.processProperties(arguments);\n}\nGibberish.Saw3.prototype = Gibberish._oscillator;\n\n/**#Gibberish.PWM - Oscillator\nA bandlimited pulsewidth modulation wave created using FM feedback, see http://scp.web.elte.hu/papers/synthesis1.pdf.\n  \n## Example Usage##\n`// make a pwm wave  \nGibberish.init();  \na = new Gibberish.PWM(330, .4, .9).connect();`\n- - - -\n**/\n/**###Gibberish.PWM.frequency : property  \nNumber. From 20 - 20000 hz.\n**/\n/**###Gibberish.PWM.amp : property  \nNumber. A linear value specifying relative ampltiude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n/**###Gibberish.PWM.pulsewidth : property  \nNumber. 0..1. The width of the waveform's duty cycle.\n**/\nGibberish.PWM = function() {\n  var osc = 0,\n      osc2= 0,\n      _osc= 0,\n      _osc2=0,\n      phase = 0,\n      a0 = 2.5,\n      a1 = -1.5,\n      history = 0,\n      sin = Math.sin,\n      scale = 11;\n      pi_2 = Math.PI * 2,\n      test = 0,\n      sr = Gibberish.context.sampleRate;\n\n  Gibberish.extend(this, {\n    name: 'pwm',\n    properties : {\n      frequency: 440,\n      amp: .15,\n      pulsewidth: .05,\n      sr: Gibberish.context.sampleRate,\n    },\n/**###Gibberish.PWM.callback : method  \nReturns a single sample of output.  \n  \nparam **frequency** Number. The frequency to be used to calculate output.  \nparam **amp** Number. The amplitude to be used to calculate output.  \nparam **pulsewidth** Number. The duty cycle of the waveform\n**/    \n    callback : function(frequency, amp, pulsewidth) {\n      var w = frequency / sr,\n          n = .5 - w,\n          scaling = scale * n * n * n * n,\n          DC = .376 - w * .752,\n          norm = 1 - 2 * w,\n          out = 0;\n          \n      phase += w;\n      phase -= phase > 1 ? 2 : 0;\n      \n      osc = (osc  + sin( pi_2 * (phase + osc  * scaling ) ) ) * .5;\n      osc2 =(osc2 + sin( pi_2 * (phase + osc2 * scaling + pulsewidth) ) ) * .5;\n      out = osc2 - osc;\n      \n      out = a0 * out + a1 * (_osc - _osc2);\n      _osc = osc;\n      _osc2 = osc2;\n\n      return out * norm * amp;\n    },\n  });\n  \n  Object.defineProperty(this, 'scale', {\n    get : function() { return scale; },\n    set : function(val) { scale = val; }\n  });\n  \n  this.init();\n  this.oscillatorInit();\n  this.processProperties(arguments);  \n};\nGibberish.PWM.prototype = Gibberish._oscillator;\n\n/**#Gibberish.Noise - Oscillator\nA white noise oscillator\n\n## Example Usage##\n`// make some noise\nGibberish.init();  \na = new Gibberish.Noise(.4).connect();`\n- - - -\n**/\n/**###Gibberish.Noise.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\nGibberish.Noise = function() {\n  var rnd = Math.random;\n  \n  Gibberish.extend(this, {\n    name:'noise',\n    properties: {\n      amp:1,\n    },\n    \n    callback : function(amp){ \n      return (rnd() * 2 - 1) * amp;\n    },\n  });\n  \n  this.init();\n  this.oscillatorInit();\n  this.processProperties(arguments);  \n};\nGibberish.Noise.prototype = Gibberish._oscillator;\n\n// this file is dependent on oscillators.js\n\n/**#Gibberish.KarplusStrong - Physical Model\nA plucked-string model.  \n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.KarplusStrong({ damping:.6 }).connect();  \na.note(440);\n`\n- - - -\n**/\n/**###Gibberish.KarplusStrong.blend : property  \nNumber. 0..1. The likelihood that the sign of any given sample will be flipped. A value of 1 means there is no chance, a value of 0 means each samples sign will be flipped. This introduces noise into the model which can be used for various effects.\n**/\n/**###Gibberish.KarplusStrong.damping : property  \nNumber. 0..1. Higher amounts of damping shorten the decay of the sound generated by each note.\n**/\n/**###Gibberish.KarplusStrong.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n/**###Gibberish.KarplusStrong.channels : property  \nNumber. Default 2. If two channels, the signal may be panned.\n**/\n/**###Gibberish.KarplusStrong.pan : property  \nNumber. Default 0. The position in the stereo spectrum for the sound, from -1..1.\n**/\nGibberish.KarplusStrong = function() {\n  var phase   = 0,\n      buffer  = [0],\n      last    = 0,\n      rnd     = Math.random,\n      panner  = Gibberish.makePanner(),\n      sr      = Gibberish.context.sampleRate,\n      out     = [0,0];\n      \n  Gibberish.extend(this, {\n    name:\"karplus_strong\",\n    frequency : 0,\n    properties: { blend:1, damping:0, amp:1, channels:2, pan:0, velocity:1  },\n  \n    note : function( frequency, velocity ) {\n      if( typeof frequency === 'undefined' ) return\n\n      var _size = Math.floor(sr / frequency);\n      buffer.length = 0;\n    \n      for(var i = 0; i < _size; i++) {\n        buffer[i] = rnd() * 2 - 1; // white noise\n      }\n      \n      if( velocity ) this.velocity = velocity\n\n      this.frequency = frequency;\n    },\n\n    callback : function(blend, damping, amp, channels, pan, velocity ) { \n      var val = buffer.shift();\n      var rndValue = (rnd() > blend) ? -1 : 1;\n\t\t\t\t\n  \t  damping = damping > 0 ? damping : 0;\n\t\t\t\t\n      var value = rndValue * (val + last) * (.5 - damping / 100);\n\n      last = value;\n\n      buffer.push(value);\n\t\t\t\t\n      value *= amp * velocity;\n      return channels === 1 ? value : panner(value, pan, out);\n    },\n  })\n  .init()\n  .oscillatorInit()\n  .processProperties(arguments);\n};\nGibberish.KarplusStrong.prototype = Gibberish._oscillator;\n\nGibberish.PolyKarplusStrong = function() {\n  this.__proto__ = new Gibberish.Bus2();\n  \n  Gibberish.extend(this, {\n    name:     \"poly_karplus_strong\",\n    maxVoices:    5,\n    voiceCount:   0,\n    _frequency: 0,\n    \n    polyProperties : {\n  \t\tblend:\t\t\t1,\n      damping:    0,\n      velocity:   1\n    },\n\n    note : function(_frequency, velocity) {\n      var synth = this.children[this.voiceCount++];\n      if(this.voiceCount >= this.maxVoices) this.voiceCount = 0;\n      synth.note(_frequency, velocity);\n      this._frequency = _frequency;\n    },\n    initVoices: function() {\n      for(var i = 0; i < this.maxVoices; i++) {\n        var props = {\n          blend:   this.blend,\n          damping: this.damping,\n          channels: 2,\n          amp:      1,\n        };\n        var synth = new Gibberish.KarplusStrong(props).connect(this);\n\n        this.children.push(synth);\n      }\n    }\n  });\n  \n  this.amp = 1 / this.maxVoices;\n  this.children = [];\n  \n  if(typeof arguments[0] === 'object') {\n    this.maxVoices = arguments[0].maxVoices ? arguments[0].maxVoices : this.maxVoices\n  }\n  \n  Gibberish.polyInit(this);\n  this.initVoices()\n  \n  this.processProperties(arguments);\n  \n  this.initialized = false\n  Gibberish._synth.oscillatorInit.call(this);\n  Gibberish.dirty( this )\n};\n\n/**#Gibberish.Bus - Miscellaneous\nCreate a mono routing bus. A bus callback routes all it's inputs and scales them by the amplitude of the bus.  \n  \nFor a stereo routing bus, see [Bus2](javascript:displayDocs('Gibberish.Bus2'\\))\n\n##Example Usage##    \n`a = new Gibberish.Bus();  \nb = new Gibberish.Sine(440).connect(a);  \nc = new Gibberish.Sine(880).connect(a);  \na.amp = .1;  \na.connect();`\n  \n## Constructor     \n**param** *properties*: Object. A dictionary of property values (see below) to set for the bus on initialization.\n**/\n/**###Gibberish.Bus.amp : property  \nArray. Read-only. Relative volume for the sum of all ugens connected to the bus.\n**/\nGibberish.bus = function(){\n  this.type = 'bus';\n  \n  this.inputCodegen = function() {\n    //console.log( this, this.value, this.value.valueOf() )\n    var val = this.value.valueOf();\n    var str;\n    \n    /*if( this.value.name === 'Drums' ) {\n      str = '[ ' + val + '[0] * ' + this.amp + ', ' + val + '[1] * ' + this.amp + ']'  // works!\n    }else{\n      str = this.amp === 1 ? val : val + ' * ' + this.amp;\n    }*/\n      \n    str = val + ', ' + this.amp \n    this.codeblock = str;\n    return str;\n  };\n\n  this.addConnection = function() {\n    var position = arguments[2]\n    var arg = { \n      value:\t      arguments[0], \n      amp:\t\t      arguments[1], \n      codegen:      this.inputCodegen,\n      valueOf:      function() { return this.codegen() }\n    };\n    \n    if( typeof position !== 'undefined' ) {\n      this.inputs.splice( position,0,arg );\n    }else{\n      this.inputs.push( arg );\n    }\n\n    Gibberish.dirty( this );\n  };\n  \n  this.removeConnection = function(ugen) {\n    for(var i = 0; i < this.inputs.length; i++) {\n      if(this.inputs[i].value === ugen) {\n        this.inputs.splice(i,1);\n        Gibberish.dirty(this);\n        break;\n      }\n    }\n  };\n  \n  this.adjustSendAmount = function(ugen, amp) {\n    for(var i = 0; i < this.inputs.length; i++) {\n      if(this.inputs[i].value === ugen) {\n        this.inputs[i].amp = amp;\n        Gibberish.dirty(this);\n        break;\n      }\n    }\n  };\n  \n  this.callback = function() {\n    var amp = arguments[arguments.length - 2]; // use arguments to accommodate arbitray number of inputs without using array\n    var pan = arguments[arguments.length - 1];\n    \n    output[0] = output[1] = 0;\n    \n    for(var i = 0; i < arguments.length - 2; i+=2) {\n      var isObject = typeof arguments[i] === 'object',\n          _amp = arguments[i + 1]\n          \n      output[0] += isObject ? arguments[i][0] * _amp :arguments[i] * _amp;\n      output[1] += isObject ? arguments[i][1] * _amp: arguments[i] * _amp;\n    }\n    \n    output[0] *= amp;\n    output[1] *= amp;\n    \n    return panner(output, pan, output);\n  };\n};\n\nGibberish.bus.prototype = new Gibberish.ugen();\nGibberish._bus = new Gibberish.bus();\n\nGibberish.Bus = function() {\n  Gibberish.extend(this, {\n    name : 'bus',\n        \n    properties : {\n      inputs :  [],\n      amp :     1,\n    },\n\n    callback : function() {\n      var out = 0;\n      var length = arguments.length - 1;\n      var amp = arguments[length]; // use arguments to accommodate arbitray number of inputs without using array\n      \n      for(var i = 0; i < length; i++) {\n        out += arguments[i];\n      }\n      out *= amp;\n      \n      return out;\n    },\n  });\n\n  this.init();\n  this.processProperties(arguments);\n  \n  return this;\n};\nGibberish.Bus.prototype = Gibberish._bus;\n\n/**#Gibberish.Bus2 - Miscellaneous\nCreate a stereo outing bus. A bus callback routes all it's inputs and scales them by the amplitude of the bus.\n\n##Example Usage##    \n`a = new Gibberish.Bus2();  \nb = new Gibberish.Sine(440).connect(a);  \nc = new Gibberish.Sine(880).connect(a);  \n  \nd = new Gibberish.Sequencer({ target:a, key:'pan', values:[-.75,.75], durations:[ 22050 ] }).start();\na.connect();`\n  \n## Constructor     \n**param** *properties*: Object. A dictionary of property values (see below) to set for the bus on initialization.\n**/\n/**###Gibberish.Bus.amp : property  \nArray. Read-only. Relative volume for the sum of all ugens connected to the bus.\n**/\nGibberish.Bus2 = function() {\n  this.name = 'bus2';\n  this.type = 'bus';\n  \n  this.properties = {\n    inputs :  [],\n    amp :     1,\n    pan :     0,\n  };\n  \n  var output = [0,0],\n      panner = Gibberish.makePanner(),\n      phase = 0;\n  \n  this.callback = function() {\n    // use arguments to accommodate arbitray number of inputs without using array    \n    var args = arguments,\n        length = args.length,\n        amp = args[length - 2], \n        pan = args[length - 1]\n    \n    output[0] = output[1] = 0;\n    \n    //if(phase++ % 44100 === 0) console.log(args)\n    for(var i = 0, l = length - 2; i < l; i+= 2) {\n      var isObject = typeof args[i] === 'object',\n          _amp = args[i + 1]\n          \n      output[0] += isObject ? args[i][0] * _amp || 0 : args[i] * _amp || 0;\n      output[1] += isObject ? args[i][1] * _amp || 0 : args[i] * _amp || 0;\n    }\n    \n    output[0] *= amp;\n    output[1] *= amp;\n    \n    return panner(output, pan, output);\n  };\n  \n  this.show = function() { console.log(output, args) }\n  this.getOutput = function() { return output }\n  this.getArgs = function() { return args }\n  \n  //this.initialized = false;\n  this.init( arguments );\n  this.processProperties( arguments );\n};\nGibberish.Bus2.prototype = Gibberish._bus;\nGibberish.envelope = function() {\n    this.type = 'envelope';\n};\nGibberish.envelope.prototype = new Gibberish.ugen();\nGibberish._envelope = new Gibberish.envelope();\n\nGibberish.ExponentialDecay = function(){\n\tvar pow = Math.pow,\n      value = 0,\n      phase = 0;\n      \n  Gibberish.extend(this, {\n  \tname:\"ExponentialDecay\",\n  \tproperties: { decay:.5, length:11050 },\n\n  \tcallback: function( decay, length ) {\n  \t\tvalue = pow( decay, phase );\n  \t\tphase += 1 / length;\n\n  \t\treturn value;\n  \t},\n    \n    trigger : function() {\n      phase = typeof arguments[0] === 'number' ? arguments[0] : 0;\n    },\n  })\n  .init()\n};\nGibberish.ExponentialDecay.prototype = Gibberish._envelope;\n\nGibberish.Line = function(start, end, time, loops) {\n\tvar that = { \n\t\tname:\t\t'line',\n\n    properties : {\n  \t\tstart:\tstart || 0,\n  \t\tend:\t\tisNaN(end) ? 1 : end,\n  \t\ttime:\t\ttime || Gibberish.context.sampleRate,\n  \t\tloops:\tloops || false,\n    },\n    \n    retrigger: function( end, time ) {\n      phase = 0;\n      this.start = out\n      this.end = end\n      this.time = time\n      \n      incr = (end - out) / time\n    },\n    \n    getPhase: function() { return phase },\n    getIncr: function() { return incr },\n    getOut: function() { return out }\n\t};\n  \n\tvar phase = 0,\n\t    incr = (end - start) / time,\n      out\n  \n  //console.log(\"INCREMENT\", incr, end, start, time )\n  \n\tthis.callback = function(start, end, time, loops) {\n    var incr = (end - start) / time\n\t\tout = phase < time ? start + ( phase++ * incr) : end;\n\t\t\t\t\n\t\tphase = (out >= end && loops) ? 0 : phase;\n\t\t\n\t\treturn out;\n\t};\n  \n  this.setPhase = function(v) { phase = v; }\n  \n  Gibberish.extend(this, that);\n  \n  this.init();\n\n  return this;\n};\nGibberish.Line.prototype = Gibberish._envelope;\n\nGibberish.Ease = function( start, end, time, easein, loops ) {\n  var sqrt = Math.sqrt, out = 0, phase = 0\n      \n  start = start || 0\n  end = end || 1\n  time = time || Gibberish.context.sampleRate\n  loops = loops || false\n  easein = typeof easein === 'undefined' ? 1 : easein\n  \n\tvar that = { \n\t\tname:\t\t'ease',\n    properties : {},\n    retrigger: function( end, time ) {\n      phase = 0;\n      this.start = out\n      this.end = end\n      this.time = time      \n    },\n    \n    getPhase: function() { return phase },\n    getOut: function() { return out }\n\t};\n  \n\tthis.callback = function() {\n    var x = phase++ / time,\n        y = easein ? 1 - sqrt( 1 - x * x ) : sqrt( 1 - ((1-x) * (1-x)) )\n    \n    out = phase < time ? start + ( y * ( end - start ) ) : end\n    \n\t\t//out = phase < time ? start + ( phase++ * incr) : end;\n\t\t\t\t\n\t\tphase = (out >= end && loops) ? 0 : phase;\n\t\t\n\t\treturn out;\n\t};\n  \n  this.setPhase = function(v) { phase = v; }\n  this.setEase = function(v) {\n    easein = v\n  }\n  \n  Gibberish.extend(this, that);\n  \n  this.init();\n\n  return this;\n};\nGibberish.Ease.prototype = Gibberish._envelope;\n\n// quadratic bezier\n// adapted from http://www.flong.com/texts/code/shapers_bez/\nGibberish.Curve = function( start, end, time, a, b, fadeIn, loops ) {\n  var sqrt = Math.sqrt, \n      out = 0,\n      phase = 0\n      \n  start = start || 0\n  end = end || 1\n  time = time || Gibberish.context.sampleRate\n  a = a || .940\n  b = b || .260\n  loops = loops || false\n  fadeIn = typeof fadeIn === 'undefined' ? 1 : fadeIn\n  \n\tvar that = { \n\t\tname:\t\t'curve',\n\n    properties : {},\n    \n    retrigger: function( end, time ) {\n      phase = 0;\n      this.start = out\n      this.end = end\n      this.time = time\n      \n      incr = (end - out) / time\n    },\n    \n    getPhase: function() { return phase },\n    getOut: function() { return out }\n\t};\n  \n\tthis.callback = function() {\n    var x = phase++ / time,\n        om2a = 1 - 2 * a,\n        t = ( sqrt( a*a + om2a*x ) - a ) / om2a,\n        y = (1-2*b) * (t*t) + (2*b) * t\n    \n    out = phase < time ? start + ( y * ( end - start ) ) : end\n    \n    if( !fadeIn ) out =  1 - out\n    \n\t\t//out = phase < time ? start + ( phase++ * incr) : end;\n\t\t\t\t\n\t\tphase = (out >= end && loops) ? 0 : phase;\n\t\t\n\t\treturn out;\n\t};\n  \n  this.setPhase = function(v) { phase = v; }\n  \n  Gibberish.extend(this, that);\n  \n  this.init();\n\n  return this;\n};\nGibberish.Curve.prototype = Gibberish._envelope;\n\nGibberish.Lines = function( values, times, loops ) {\n  var out = values[0],\n      phase = 0,\n      valuesPhase = 1,\n      timesPhase = 0,\n      targetValue = 0,\n      targetTime = 0,\n      end = false,\n      incr\n  \n  \n  if( typeof values === 'undefined' ) values = [ 0,1 ]\n  if( typeof times  === 'undefined' ) times  = [ 44100 ]  \n    \n  targetValue = values[ valuesPhase ]\n  targetTime  = times[ 0 ]\n  \n  incr = ( targetValue - values[0] ) / targetTime\n  //console.log( \"current\", out, \"target\", targetValue, \"incr\", incr )\n  \n  loops = loops || false\n  \n\tvar that = { \n\t\tname:\t\t'lines',\n\n    properties : {},\n    \n    retrigger: function() {\n      phase = 0\n      out = values[0]\n      targetTime = times[ 0 ]\n      targetValue = values[ 1 ]\n      valuesPhase = 1\n      timesPhase = 0\n      incr = ( targetValue - out ) / targetTime\n      end = false\n    },\n    \n    getPhase: function() { return phase },\n    getOut:   function() { return out }\n\t};\n  \n  that.run = that.retrigger\n  \n\tthis.callback = function() {\n    if( phase >= targetTime && !end ) {\n      if( valuesPhase < values.length - 1 ) {\n        var timeStep = times[ ++timesPhase % times.length ]\n        targetTime = phase + timeStep\n        targetValue = values[ ++valuesPhase % values.length ]\n        incr = ( targetValue - out ) / timeStep        \n      }else{\n        if( !loops ) {\n          end = true\n          out = values[ values.length - 1 ]\n        }else{\n          phase = 0\n          out = values[0]\n          targetTime = times[ 0 ]\n          targetValue = values[ 1 ]\n          valuesPhase = 1\n          timesPhase = 0\n          incr = ( targetValue - out ) / targetTime\n        }\n      }\n    }else if( !end ) {\n      out += incr\n      phase++\n    }\n\t\t\n\t\treturn out;\n\t};\n  \n  this.setPhase = function(v) { phase = v; }\n  \n  Gibberish.extend(this, that);\n  \n  this.init();\n\n  return this;\n};\nGibberish.Lines.prototype = Gibberish._envelope;\n\nGibberish.AD = function(_attack, _decay) {\n  var phase = 0,\n      state = 0;\n      \n  Gibberish.extend( this,{\n    name : \"AD\",\n  \tproperties : {\n      attack :\t_attack || 10000,\n  \t  decay  :\t_decay  || 10000,\n    },\n\n  \trun : function() {\n  \t\tstate = 0;\n      phase = 0;\n  \t\treturn this;\t\t\t\n    },\n  \tcallback : function(attack,decay) {\n  \t\tattack = attack < 0 ? 22050 : attack;\n  \t\tdecay  = decay  < 0 ? 22050 : decay;\t\t\t\t\n  \t\tif(state === 0){\n  \t\t\tvar incr = 1 / attack;\n  \t\t\tphase += incr;\n  \t\t\tif(phase >=1) {\n  \t\t\t\tstate++;\n  \t\t\t}\n  \t\t}else if(state === 1){\n  \t\t\tvar incr = 1 / decay;\n  \t\t\tphase -= incr;\n  \t\t\tif(phase <= 0) {\n  \t\t\t\tphase = 0;\n  \t\t\t\tstate++;;\n  \t\t\t}\t\t\t\n  \t\t}\n  \t\treturn phase;\n    },\n    getState : function() { return state; },\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.AD.prototype = Gibberish._envelope;\n\nGibberish.ADSR = function(attack, decay, sustain, release, attackLevel, sustainLevel, requireReleaseTrigger) {\n\tvar that = { \n    name:   \"adsr\",\n\t\ttype:\t\t\"envelope\",\n    'requireReleaseTrigger' : typeof requireReleaseTrigger !== 'undefined' ? requireReleaseTrigger : false,\n    \n    properties: {\n  \t\tattack:\t\tisNaN(attack) ? 10000 : attack,\n  \t\tdecay:\t\tisNaN(decay) ? 10000 : decay,\n  \t\tsustain: \tisNaN(sustain) ? 22050 : sustain,\n  \t\trelease:\tisNaN(release) ? 10000 : release,\n  \t\tattackLevel:  attackLevel || 1,\n  \t\tsustainLevel: sustainLevel || .5,\n      releaseTrigger: 0,\n    },\n\n\t\trun: function() {\n\t\t\tthis.setPhase(0);\n\t\t\tthis.setState(0);\n\t\t},\n    stop : function() {\n      this.releaseTrigger = 1\n    }\n\t};\n\tGibberish.extend(this, that);\n\t\n\tvar phase = 0,\n\t    state = 0,\n      rt  = 0,\n      obj = this;\n      \n  this.callback = function(attack,decay,sustain,release,attackLevel,sustainLevel,releaseTrigger) {\n\t\tvar val = 0;\n    rt = rt === 1 ? 1 : releaseTrigger;\n\t\tif(state === 0){\n\t\t\tval = phase / attack * attackLevel;\n\t\t\tif(++phase / attack >= 1) {\n\t\t\t\tstate++;\n\t\t\t\tphase = decay;\n\t\t\t}\n\t\t}else if(state === 1) {\n\t\t\tval = phase / decay * (attackLevel - sustainLevel) + sustainLevel;\n\t\t\tif(--phase <= 0) {\n\t\t\t\tif(sustain !== null){\n\t\t\t\t\tstate += 1;\n\t\t\t\t\tphase = sustain;\n\t\t\t\t}else{\n\t\t\t\t\tstate += 2;\n\t\t\t\t\tphase = release;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(state === 2) {\n\t\t\tval = sustainLevel;\n      if( obj.requireReleaseTrigger && rt ){\n        state++;\n        phase = release;\n        obj.releaseTrigger = 0;\n        rt = 0;\n      }else if(phase-- <= 0 && !obj.requireReleaseTrigger) {\n\t\t\t\tstate++;\n\t\t\t\tphase = release;\n\t\t\t}\n\t\t}else if(state === 3) {\n      phase--;\n\t\t\tval = (phase / release) * sustainLevel;\n\t\t\tif(phase <= 0) {\n        state++;\n      }\n\t\t}\n\t\treturn val;\n\t};\n  this.call = function() {\n    return this.callback( this.attack, this.decay, this.sustain, this.release, this.attackLevel, this.sustainLevel, this.releaseTrigger )\n  };\n  this.getPhase = function() { return phase; };\n\tthis.setPhase = function(newPhase) { phase = newPhase; };\n\tthis.setState = function(newState) { state = newState; phase = 0; };\n\tthis.getState = function() { return state; };\t\t\n\t\n  this.init();\n  \n\treturn this;\n};\nGibberish.ADSR.prototype = Gibberish._envelope;\n\nGibberish.ADR = function(attack, decay, release, attackLevel, releaseLevel) {\n\tvar that = { \n    name:   \"adr\",\n\t\ttype:\t\t\"envelope\",\n    \n    properties: {\n  \t\tattack:\t\tisNaN(attack) ? 11025 : attack,\n  \t\tdecay:\t\tisNaN(decay) ? 11025 : decay,\n  \t\trelease:\tisNaN(release) ? 22050 : release,\n  \t\tattackLevel:  attackLevel || 1,\n  \t\treleaseLevel: releaseLevel || .2,\n    },\n\n\t\trun: function() {\n\t\t\tthis.setPhase(0);\n\t\t\tthis.setState(0);\n\t\t},\n\t};\n\tGibberish.extend(this, that);\n\t\n\tvar phase = 0;\n\tvar state = 0;\n  \n\tthis.callback = function(attack,decay,release,attackLevel,releaseLevel) {\n\t\tvar val = 0;\n\t\tif(state === 0){\n\t\t\tval = phase / attack * attackLevel;\n\t\t\tif(++phase / attack === 1) {\n\t\t\t\tstate++;\n\t\t\t\tphase = decay;\n\t\t\t}\n\t\t}else if(state === 1) {\n\t\t\tval = (phase / decay) * (attackLevel - releaseLevel) + releaseLevel;\n\t\t\tif(--phase <= 0) {\n\t\t\t\t\tstate += 1;\n\t\t\t\t\tphase = release;\n\t\t\t}\n\t\t}else if(state === 2){\n      phase--;\n      \n\t\t\tval = (phase / release) * releaseLevel;\n\t\t\tif(phase <= 0) {\n        state++;\n      }\n\t\t}\n\t\treturn val;\n\t};\n\tthis.setPhase = function(newPhase) { phase = newPhase; };\n\tthis.setState = function(newState) { state = newState; phase = 0; };\n\tthis.getState = function() { return state; };\t\t\n\t\n  this.init();\n  \n\treturn this;\n};\nGibberish.ADR.prototype = Gibberish._envelope;\n/*\nAnalysis ugens have two callbacks, one to perform the analysis and one to output the results.\nThis allows the analysis to occur at the end of the callback while the outback can occur at\nthe beginning, in effect using a single sample delay.\n\nBecause of the two callbacks, there are also two codegen methods. The default codegens used by\nthe analysis prototype object should be fine for most applications.\n*/\n\nGibberish.analysis = function() {\n  this.type = 'analysis';\n  \n  this.codegen = function() {\n    if(Gibberish.memo[this.symbol]) {\n      return Gibberish.memo[this.symbol];\n    }else{\n      var v = this.variable ? this.variable : Gibberish.generateSymbol('v');\n      Gibberish.memo[this.symbol] = v;\n      this.variable = v;\n      Gibberish.callbackArgs.push( this.symbol )\n      Gibberish.callbackObjects.push( this.callback )\n    }\n        \n    this.codeblock = \"var \" + this.variable + \" = \" + this.symbol + \"();\\n\";\n    \n    if( Gibberish.codeblock.indexOf( this.codeblock ) === -1 ) Gibberish.codeblock.push( this.codeblock )\n    return this.variable;\n  }\n  \n  this.analysisCodegen = function() {\n    // TODO: can this be memoized somehow?\n    //if(Gibberish.memo[this.analysisSymbol]) {\n    //  return Gibberish.memo[this.analysisSymbol];\n    //}else{\n    // Gibberish.memo[this.symbol] = v;\n    // console.log( this.input )\n    \n    var input = 0;\n    if(this.input.codegen){\n      input = this.input.codegen()\n      //console.log( \"PROPERTY UGEN\", input)\n      if(input.indexOf('op') > -1) console.log(\"ANALYSIS BUG\")\n    }else if( this.input.value ){\n      input = typeof this.input.value.codegen !== 'undefined' ? this.input.value.codegen() : this.input.value\n    }else{\n      input = 'null'\n    }\n    \n    var s = this.analysisSymbol + \"(\" + input + \",\";\n    for(var key in this.properties) {\n      if(key !== 'input') {\n        s += this[key] + \",\";\n      }\n    }\n    s = s.slice(0, -1); // remove trailing comma\n    s += \");\";\n  \n    this.analysisCodeblock = s;\n    \n    if( Gibberish.analysisCodeblock.indexOf( this.analysisCodeblock ) === -1 ) Gibberish.analysisCodeblock.push( this.analysisCodeblock )\n    \n    if( Gibberish.callbackObjects.indexOf( this.analysisCallback) === -1 ) Gibberish.callbackObjects.push( this.analysisCallback )\n    \n    //console.log( this.analysisCallback )\n        \n    return s;\n  };\n  \n  this.remove = function() {\n    Gibberish.analysisUgens.splice( Gibberish.analysisUgens.indexOf( this ), 1 )\n  }\n  \n  this.analysisInit = function() {\n    this.analysisSymbol = Gibberish.generateSymbol(this.name);\n    Gibberish.analysisUgens.push( this );\n    Gibberish.dirty(); // dirty in case analysis is not connected to graph, \n  };\n  \n};\nGibberish.analysis.prototype = new Gibberish.ugen();\nGibberish._analysis = new Gibberish.analysis();\n\nGibberish.Follow = function() {\n  this.name = 'follow';\n    \n  this.properties = {\n    input : 0,\n    bufferSize : 4410,\n    mult : 1,\n    useAbsoluteValue:true // for amplitude following, false for other values\n  };\n  \n  this.storage = [];\n    \n  var abs = Math.abs,\n      history = [0],\n      sum = 0,\n      index = 0,\n      value = 0,\n      phase = 0;\n      \n  this.analysisCallback = function(input, bufferSize, mult, useAbsoluteValue ) {\n    if( typeof input === 'object' ) input = input[0] + input[1]\n    \n  \tsum += useAbsoluteValue ? abs(input) : input;\n  \tsum -= history[index];\n    \n  \thistory[index] = useAbsoluteValue ? abs(input) : input;\n    \n  \tindex = (index + 1) % bufferSize;\n\t\t\t\n    // if history[index] isn't defined set it to 0 \n    // TODO: does this really need to happen here? I guess there were clicks on initialization...\n    history[index] = history[index] ? history[index] : 0;\n  \tvalue = (sum / bufferSize) * mult;\n  };\n    \n  this.callback = this.getValue = function() { return value; };\n    \n  this.init();\n  this.analysisInit();\n  this.processProperties( arguments );\n  \n  var oldBufferSize = this.__lookupSetter__( 'bufferSize' ),\n      bs = this.bufferSize\n  \n  Object.defineProperty( this, 'bufferSize', {\n    get: function() { return bs },\n    set: function(v) { bs = v; sum = 0; history = [0]; index = 0; }\n  })\n  \n  this.getStorage = function() { return this.storage; }\n};\nGibberish.Follow.prototype = Gibberish._analysis;\n\nGibberish.SingleSampleDelay = function() {\n  this.name = 'single_sample_delay';\n  \n  this.properties = {\n    input : arguments[0] || 0,\n    amp   : arguments[1] || 1,\n  };\n  \n  var value = 0,\n      phase = 0;\n  \n  this.analysisCallback = function(input, amp) {\n    /*if(typeof input === 'object') {\n      value = typeof input === 'object' ? [input[0] * amp, input[1] * amp ] : input * amp;\n    }else{\n      value = input * amp;\n    }*/\n    value = input\n    //if(phase++ % 44100 === 0) console.log(value, input, amp)\n  };\n  \n  this.callback = function() {\n    //if(phase % 44100 === 0) console.log(value)\n    \n    return value;\n  };\n  \n  this.getValue = function() { return value }\n  this.init();\n  this.analysisInit();\n  this.processProperties( arguments );\n  \n};\nGibberish.SingleSampleDelay.prototype = Gibberish._analysis;\n\nGibberish.Record = function(_input, _size, oncomplete) {\n  var buffer      = new Float32Array(_size),\n      phase       = 0,\n      isRecording = false,\n      self        = this;\n\n  Gibberish.extend(this, {\n    name: 'record',\n    'oncomplete' :  oncomplete,\n    \n    properties: {\n      input:   0,\n      size:    _size || 0,\n    },\n    \n    analysisCallback : function(input, length) {\n      if(isRecording) {\n        buffer[phase++] = typeof input === 'object' ? input[0] + input[1] : input;\n        \n        if(phase >= length) {\n          isRecording = false;\n          self.remove();\n        }\n      }\n    },\n    \n    record : function() {\n      phase = 0;\n      isRecording = true;\n      return this;\n    },\n    \n    getBuffer : function() { return buffer; },\n    getPhase : function() { return phase; },\n    \n    remove : function() {\n      if(typeof this.oncomplete !== 'undefined') this.oncomplete();\n      \n      for(var i = 0; i < Gibberish.analysisUgens.length; i++) {\n        var ugen = Gibberish.analysisUgens[i];\n        if(ugen === this) {\n          if( Gibberish.callbackArgs.indexOf( this.analysisSymbol) > -1 ) {\n            Gibberish.callbackArgs.splice( Gibberish.callbackArgs.indexOf( this.analysisSymbol), 1 )\n          }\n          if( Gibberish.callbackObjects.indexOf( this.analysisCallback ) > -1 ) {\n            Gibberish.callbackObjects.splice( Gibberish.callbackObjects.indexOf( this.analysisCallback ), 1 )\n          }\n          Gibberish.analysisUgens.splice(i, 1);\n          return;\n        }\n      }\n    },\n  });\n  // cannot be assigned within extend call\n  this.properties.input = _input;\n\n  this.init();\n  this.analysisInit();\n  \n  Gibberish.dirty(); // ugen is not attached to anything else\n};\nGibberish.Record.prototype = Gibberish._analysis;\nGibberish.effect = function() {\n    this.type = 'effect';\n};\nGibberish.effect.prototype = new Gibberish.ugen();\nGibberish._effect = new Gibberish.effect();\n\n/**#Gibberish.Distortion - FX\nA simple waveshaping distortion that adaptively scales its gain based on the amount of distortion applied.\n  \n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Distortion({ input:a, amount:30 }).connect();  \na.note(440);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Distortion.amount : property  \nNumber. The amount of distortion to apply. This number cannot be set lower than 2.\n**/\nGibberish.Distortion = function() {\n  var abs = Math.abs, \n      log = Math.log, \n      ln2 = Math.LN2;\n  \n  Gibberish.extend(this, {\n    name : 'distortion',\n    \n    properties : {\n      input  : 0,\n      amount : 50,\n    },\n    \n    callback : function(input, amount) {\n      var x;\n      amount = amount > 2 ? amount : 2;\n      if(typeof input === 'number') {\n    \t\tx = input * amount;\n    \t\tinput = (x / (1 + abs(x))) / (log(amount) / ln2); //TODO: get rid of log / divide\n      }else{\n        x = input[0] * amount;\n        input[0] = (x / (1 + abs(x))) / (log(amount) / ln2); //TODO: get rid of log / divide\n        x = input[1] * amount;\n        input[1] = (x / (1 + abs(x))) / (log(amount) / ln2); //TODO: get rid of log / divide      \n      }\n  \t\treturn input;\n    },\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.Distortion.prototype = Gibberish._effect;\n\n/**#Gibberish.Gain - FX\nAmplitude attenutation / gain.\n  \n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Distortion({ input:a, amount:30 })\nc = new Gibberish.Gain({ input:b, amount:.5 }).connect()\n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Gain.amount : property  \nNumber. The amount of gain to multiply the inpyt signal by.\n**/\nGibberish.Gain = function() {  \n  \n  Gibberish.extend(this, {\n    name : 'gain',\n    \n    properties : {\n      input  : 0,\n      amount : 1,\n    },\n    \n    callback : function(input, amount) {\n      if(typeof input === 'number') {\n        input *= amount;\n      }else{\n        input[0] *=amount;\n        input[1] *=amount;\n      }\n  \t\treturn input;\n    },\n  })\n  .init()\n  .processProperties(arguments);\n  \n};\nGibberish.Gain.prototype = Gibberish._effect;\n\n/**#Gibberish.Delay - FX\nA simple echo effect.\n  \n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Delay({ input:a, time:22050, feedback:.35 }).connect();  \na.note(440);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Delay.time : property  \nNumber. The delay time as measured in samples\n**/\n/**###Gibberish.Delay.feedback : property  \nNumber. The amount of feedback that the delay puts into its buffers.\n**/\nGibberish.Delay = function() {\n  var buffers = [],\n      phase = 0;\n  \n  buffers.push( new Float32Array(Gibberish.context.sampleRate * 2) );\n  buffers.push( new Float32Array(Gibberish.context.sampleRate * 2) );\n  \n  Gibberish.extend(this, {\n  \tname:\"delay\",\n  \tproperties:{ input:0, time: 22050, feedback: .5, wet:1, dry:1, rate:1 },\n\t\t\t\t\n  \tcallback : function( sample, time, feedback, wet, dry, rate ) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      \n  \t\tvar _phase = phase++ % 88200;\n      time = time / rate;\n  \t\tvar delayPos = (_phase + ( time | 0 )) % 88200;\n      \n      if(channels === 1) {\n  \t\t\tbuffers[0][delayPos] =  sample + (buffers[0][_phase] ) * feedback;\n        sample = (sample * dry) + (buffers[0][_phase] * wet);\n      }else{\n  \t\t\tbuffers[0][delayPos] =  sample[0] + buffers[0][_phase] * feedback;\n        sample[0] = (sample[0] * dry) + (buffers[0][_phase] * wet);\n  \t\t\tbuffers[1][delayPos] =  sample[1] + buffers[1][_phase] * feedback;\n        sample[1] = (sample[1] * dry) + (buffers[1][_phase] * wet);\n      }\n      \n  \t\treturn sample;\n  \t},\n  });\n  \n  var time = Math.round( this.properties.time );\n  Object.defineProperty(this, 'time', {\n    configurable: true,\n    get: function() { return time; },\n    set: function(v) { time = Math.round(v); Gibberish.dirty( this ) }\n  });\n  \n  this.init();\n  this.processProperties(arguments);\n  \n};\nGibberish.Delay.prototype = Gibberish._effect;\n\n/**#Gibberish.Decimator - FX\nA bit-crusher / sample rate reducer. Adapted from code / comments at http://musicdsp.org/showArchiveComment.php?ArchiveID=124\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Decimator({ input:a, bitDepth:4.2, sampleRate:.33 }).connect();  \na.note(440);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Decimator.bitDepth : property  \nFloat. 0..16. The number of bits the signal is truncated to. May be a floating point number.\n**/\n/**###Gibberish.Decimator.sampleRate : property  \nNumber. 0..1. The sample rate to use where 0 is 0 Hz and 1 is nyquist.\n**/\nGibberish.Decimator = function() {\n  var counter = 0,\n      hold = [],\n      pow = Math.pow,\n      floor = Math.floor;\n      \n  Gibberish.extend(this, {\n  \tname:\"decimator\",\n  \tproperties:{ input:0, bitDepth: 16, sampleRate: 1 },\n\t\t\t\t\n  \tcallback : function(sample, depth, rate) {\n  \t\tcounter += rate;\n      var channels = typeof sample === 'number' ? 1 : 2;\n      \n      if(channels === 1) {\n  \t\t\tif(counter >= 1) {\n  \t\t\t\tvar bitMult = pow( depth, 2.0 );\n  \t\t\t\thold[0]  = floor( sample * bitMult ) / bitMult;\n  \t\t\t\tcounter -= 1;\n  \t\t\t}\n  \t\t\tsample = hold[0];\n      }else{\n  \t\t\tif(counter >= 1) {\n  \t\t\t\tvar bitMult = pow( depth, 2.0 );\n  \t\t\t\thold[0]  = floor( sample[0] * bitMult ) / bitMult;\n  \t\t\t\thold[1]  = floor( sample[1] * bitMult ) / bitMult;          \n  \t\t\t\tcounter -= 1;\n  \t\t\t}\n  \t\t\tsample = hold;\n      }\n\t\t\t\t\t\n  \t\treturn sample;\n  \t},\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.Decimator.prototype = Gibberish._effect;\n\n/**#Gibberish.RingModulation - FX\nThe name says it all. This ugen also has a mix property to control the ratio of wet to dry output.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.RingModulation({ input:a, frequency:1000, amp:.4, mix:1 }).connect();  \na.note(440);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.RingModulation.frequency : property  \nFloat. The frequency of the ring modulation modulator wave.\n**/\n/**###Gibberish.RingModulation.amp : property  \nFloat. The amplitude of the ring modulation modulator wave.\n**/\n/**###Gibberish.RingModulation.mix : property  \nFloat. 0..1. The wet/dry output ratio. A value of 1 means a completely wet signal, a value of 0 means completely dry.\n**/\nGibberish.RingModulation = function() {\n  var sin = new Gibberish.Sine().callback,\n      output = [0,0];\n      \n  Gibberish.extend( this, { \n  \tname : \"ringmod\",\n  \n\t  properties : { input:0, frequency:440, amp:.5, mix:.5 },\n\n    callback : function(sample, frequency, amp, mix) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      var output1 = channels === 1 ? sample : sample[0];\n      \n      var mod = sin(frequency, amp);\n      \n      output1 = output1 * (1-mix) + (output1 * mod) * mix;\n      \n      if(channels === 2) {\n        var output2 = sample[1];\n        output2 = output2 * (1-mix) + (output2 * mod) * mix;\n\n        output[0] = output1;\n        output[1] = output2;\n        return output;\n      }\n      \n\t\t  return output1; // return mono\n  \t},\n  })\n  .init()\n  .processProperties(arguments); \n};\nGibberish.RingModulation.prototype = Gibberish._effect;\n\n\n/**#Gibberish.DCBlock - FX\nA one-pole filter for removing bias.\n\n## Example Usage##\n` `  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.DCBlock.input : property  \nFloat. The input ugen to remove bias from.\n**/\n\nGibberish.DCBlock = function() {\n  var x1 = 0, y1 = 0\n\n\tGibberish.extend(this, {\n  \tname: 'dcblock',\n    type: 'effect',\n    \n    properties : {\n      input : 0, \n    },\n    \n    reset : function() {\n      x1 = 0;\n      y1 = 0;\n    },\n    \n    callback : function(input) {\n      var y = input - x1 + y1 * .9997\n      x1 = input\n      y1 = y\n    \n      return y;\n    }\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.DCBlock.prototype = Gibberish._effect;\n\n/**#Gibberish.Tremolo - FX\nA basic amplitude modulation effect.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \nb = new Gibberish.Tremolo({input:a, frequency:4, amp:1});   \na.note(880);   \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Tremolo.input : property  \nFloat. The input to apply the tremolo effect to\n**/\n/**###Gibberish.Tremolo.frequency : property  \nFloat. The speed of the tremolo effect, measured in Hz\n**/\n/**###Gibberish.Tremolo.amp : property  \nFloat. The magnitude of the tremolo effect.\n**/\n\nGibberish.Tremolo = function() {\n  var modulationCallback = new Gibberish.Sine().callback\n  \n\tGibberish.extend(this, {\n  \tname: 'tremolo',\n    type: 'effect',\n    \n    properties : {\n      input : 0,\n      frequency:2.5,\n      amp:.5,\n    },\n  \n    callback : function( input, frequency, amp ) {\n      var channels = typeof input === 'number' ? 1 : 2,\n          modAmount = modulationCallback( frequency, amp )\n      \n      if(channels === 1) {\n        input *= modAmount\n      }else{\n        input[0] *= modAmount\n        input[1] *= modAmount\n      }\n      \n      return input;\n    }\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.Tremolo.prototype = Gibberish._effect;\n\n/**#Gibberish.OnePole - FX\nA one-pole filter for smoothing property values. This is particularly useful when the properties are being controlled interactively. You use the smooth method to apply the filter.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \nb = new Gibberish.OnePole({input:a.properties.frequency, a0:.0001, b1:.9999});  \nb.smooth('frequency', a);  \na.note(880);  \na.note(440);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.OnePole.input : property  \nFloat. The property to smooth. You should always refer to this property through the properties dictionary of the ugen. In general it is much easier to use the smooth method of the OnePole than to set this property manually.\n**/\n/**###Gibberish.OnePole.a0 : property  \nFloat. The value the input is multiplied by.\n**/\n/**###Gibberish.OnePole.b1 : property  \nFloat. The value this pole of the filter is multiplied by.\n**/\nGibberish.OnePole = function() {\n  var history = 0,\n      phase = 0;\n      \n\tGibberish.extend(this, {\n  \tname: 'onepole',\n    type: 'effect',\n    \n    properties : {\n      input : 0,\n      a0 : .15,           \n      b1 : .85, \n    },\n    \n    callback : function(input, a0, b1) {\n      var out = input * a0 + history * b1;\n      history = out;\n    \n      return out;\n    },\n\n/**###Gibberish.OnePole.smooth : method  \nUse this to apply the filter to a property of an object.\n\nparam **propertyName** String. The name of the property to smooth.  \nparam **object** Object. The object containing the property to be smoothed\n**/    \n    smooth : function(property, obj) {\n      this.input = obj[ property ]\n      history = this.input\n      obj[ property ] = this\n      \n      this.obj = obj\n      this.property = property\n      \n      this.oldSetter = obj.__lookupSetter__( property )\n      this.oldGetter = obj.__lookupGetter__( property )\n      \n      var op = this\n      Object.defineProperty( obj, property, {\n        get : function() { return op.input },\n        set : function(v) { \n          op.input = v\n        }\n      })\n    },\n\n/**###Gibberish.OnePole.remove : method  \nRemove OnePole from assigned ugen property. This will effectively remove the filter from the graph and return the normal target ugen property behavior.\n**/      \n    remove : function() {\n      Object.defineProperty( this.obj, this.property, {\n        get: this.oldGetter,\n        set: this.oldSetter\n      })\n      \n      this.obj[ this.property ] = this.input\n    }\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.OnePole.prototype = Gibberish._effect;\n\n/**#Gibberish.Filter24 - FX\nA four pole ladder filter. Adapted from Arif Ove Karlsne's 24dB ladder approximation: http://musicdsp.org/showArchiveComment.php?ArchiveID=141.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Filter24({input:a, cutoff:.2, resonance:4}).connect();  \na.note(1760);   \na.note(440);  \na.isLowPass = false;  \na.note(220);  \na.note(1760);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Filter24.input : property  \nObject. The ugen that should feed the filter.\n**/\n/**###Gibberish.Filter24.cutoff : property  \nNumber. 0..1. The cutoff frequency for the synth's filter.\n**/\n/**###Gibberish.Filter24.resonance : property  \nNumber. 0..50. Values above 4.5 are likely to produce shrieking feedback. You are warned.\n**/\n/**###Gibberish.Filter24.isLowPass : property  \nBoolean. Default true. Whether to use a low-pass or high-pass filter.\n**/\nGibberish.Filter24 = function() {\n  var poles  = [0,0,0,0],\n      poles2 = [0,0,0,0],\n      output = [0,0],\n      phase  = 0,\n      _cutoff = isNaN(arguments[0]) ? .1 : arguments[0],\n      _resonance = isNaN(arguments[1]) ? 3 : arguments[1]\n      _isLowPass = typeof arguments[2] !== 'undefined' ? arguments[2] : true;\n      \n  Gibberish.extend( this, { \n  \tname : \"filter24\",\n  \n\t  properties : { input:0, cutoff:_cutoff, resonance:_resonance, isLowPass:_isLowPass },\n\n    callback : function(sample, cutoff, resonance, isLowPass) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      var output1 = channels === 1 ? sample : sample[0];\n      \n\t\t\tvar rezz = poles[3] * resonance; \n\t\t\trezz = rezz > 1 ? 1 : rezz;\n\t\t\t\t\t\t\n\t\t\tcutoff = cutoff < 0 ? 0 : cutoff;\n\t\t\tcutoff = cutoff > 1 ? 1 : cutoff;\n\t\t\t\t\t\t\n\t\t\toutput1 -= rezz;\n\n\t\t\tpoles[0] = poles[0] + ((-poles[0] + output1) * cutoff);\n\t\t\tpoles[1] = poles[1] + ((-poles[1] + poles[0])  * cutoff);\n\t\t\tpoles[2] = poles[2] + ((-poles[2] + poles[1])  * cutoff);\n\t\t\tpoles[3] = poles[3] + ((-poles[3] + poles[2])  * cutoff);\n\n\t\t\toutput1 = isLowPass ? poles[3] : output1 - poles[3];\n      \n      if(channels === 2) {\n        var output2 = sample[1];\n\n  \t\t\trezz = poles2[3] * resonance; \n  \t\t\trezz = rezz > 1 ? 1 : rezz;\n\n  \t\t\toutput2 -= rezz;\n\n  \t\t\tpoles2[0] = poles2[0] + ((-poles2[0] + output2) * cutoff);\n  \t\t\tpoles2[1] = poles2[1] + ((-poles2[1] + poles2[0])  * cutoff);\n  \t\t\tpoles2[2] = poles2[2] + ((-poles2[2] + poles2[1])  * cutoff);\n  \t\t\tpoles2[3] = poles2[3] + ((-poles2[3] + poles2[2])  * cutoff);\n\n  \t\t\toutput2 = isLowPass ? poles2[3] : output2 - poles2[3];\n        output[0] = output1;\n        output[1] = output2;\n        \n        return output;\n      }\n      \n\t\t  return output1; // return mono\n  \t},\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.Filter24.prototype = Gibberish._effect;\n\n/**#Gibberish.SVF - FX\nA two-pole state variable filter. This filter calculates coefficients on a per-sample basis, so that you can easily modulate cutoff and Q. Can switch between low-pass, high-pass, band and notch modes.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.SVF({input:a, cutoff:200, Q:4, mode:0});  \na.note(1760);   \na.note(440);  \na.mode = 2;\na.note(220);  \na.note(1760);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.SVF.input : property  \nObject. The ugen that should feed the filter.\n**/\n/**###Gibberish.SVF.cutoff : property  \nNumber. 0..22050. The cutoff frequency for the synth's filter. Note that unlike the Filter24, this is measured in Hz.\n**/\n/**###Gibberish.SVF.resonance : property  \nNumber. 0..50. Values above 4.5 are likely to produce shrieking feedback. You are warned.\n**/\n/**###Gibberish.SVF.mode : property  \nNumber. 0..3. 0 = lowpass, 1 = highpass, 2 = bandpass, 3 = notch.\n**/\nGibberish.SVF = function() {\n\tvar d1 = [0,0], d2 = [0,0], pi= Math.PI, out = [0,0];\n  \n  Gibberish.extend( this, {\n  \tname:\"SVF\",\n  \tproperties : { input:0, cutoff:440, Q:2, mode:0, sr: Gibberish.context.sampleRate },\n\t\t\t\t\n  \tcallback: function(sample, frequency, Q, mode, sr) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      var output1 = channels === 1 ? sample : sample[0];\n      \n  \t\tvar f1 = 2 * pi * frequency / sr;\n  \t\tQ = 1 / Q;\n\t\t\t\t\t\n\t\t\tvar l = d2[0] + f1 * d1[0];\n\t\t\tvar h = output1 - l - Q * d1[0];\n\t\t\tvar b = f1 * h + d1[0];\n\t\t\tvar n = h + l;\n\t\t\t\t\t\t\n\t\t\td1[0] = b;\n\t\t\td2[0] = l;\n      \n\t\t\tif(mode === 0) \n\t\t\t\toutput1 = l;\n\t\t\telse if(mode === 1)\n\t\t\t\toutput1 = h;\n\t\t\telse if(mode === 2)\n\t\t\t\toutput1 = b;\n\t\t\telse\n\t\t\t\toutput1 = n;\n        \n      if(channels === 2) {\n        var output2 = sample[1];\n  \t\t\tvar l = d2[1] + f1 * d1[1];\n  \t\t\tvar h = output2 - l - Q * d1[1];\n  \t\t\tvar b = f1 * h + d1[1];\n  \t\t\tvar n = h + l;\n\t\t\t\t\t\t\n  \t\t\td1[1] = b;\n  \t\t\td2[1] = l;\n      \n  \t\t\tif(mode === 0) \n  \t\t\t\toutput2 = l;\n  \t\t\telse if(mode === 1)\n  \t\t\t\toutput2 = h;\n  \t\t\telse if(mode === 2)\n  \t\t\t\toutput2 = b;\n  \t\t\telse\n  \t\t\t\toutput2 = n;\n          \n        out[0] = output1; out[1] = output2;\n      }else{\n        out = output1;\n      }\n\n  \t\treturn out;\n  \t},\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.SVF.prototype = Gibberish._effect;\n\n/**#Gibberish.Biquad - FX\nA two-pole biquad filter. Currently, you must manually call calculateCoefficients every time mode, cutoff or Q changes; thus this filter isn't good for samplerate modulation.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Biquad({input:a, cutoff:200, Q:4, mode:\"LP\"}).connect();  \na.note(1760);   \na.note(440);  \na.mode = \"HP\";\na.note(220);  \na.note(1760);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Biquad.input : property  \nObject. The ugen that should feed the filter.\n**/\n/**###Gibberish.Biquad.cutoff : property  \nNumber. 0..22050. The cutoff frequency for the synth's filter. Note that unlike the Filter24, this is measured in Hz.\n**/\n/**###Gibberish.Biquad.Q : property  \nNumber. 0..50. Values above 4.5 are likely to produce shrieking feedback. You are warned.\n**/\n/**###Gibberish.Biquad.mode : property  \nNumber. 0..3. \"LP\" = lowpass, \"HP\" = highpass, \"BP\" = bandpass\n**/\nGibberish.Biquad = function() {\n  var x1L = 0,\n      x2L = 0,\n      y1L = 0,\n      y2L = 0,\n      x1R = 0,\n      x2R = 0,\n      y1R = 0,\n      y2R = 0,\n      out = [0,0],\n\t    b0 = 0.001639,\n\t    b1 = 0.003278,\n\t    b2 = 0.001639,\n\t    a1 = -1.955777,\n\t    a2 = 0.960601,\n      _mode = \"LP\",\n    \t_cutoff = 2000,\n      _Q = .5,\n      sr = Gibberish.context.sampleRate,\n      _phase = 0;\n      \n\tGibberish.extend(this, {\n\t\tname: \"biquad\",\n\n\t  properties: {\n      input: null,\n\t  },\n\n\t  calculateCoefficients: function() {\n      switch (_mode) {\n\t      case \"LP\":\n           var w0 = 2 * Math.PI * _cutoff / sr,\n               sinw0 = Math.sin(w0),\n               cosw0 = Math.cos(w0),\n               alpha = sinw0 / (2 * _Q);\n           b0 = (1 - cosw0) / 2,\n           b1 = 1 - cosw0,\n           b2 = b0,\n           a0 = 1 + alpha,\n           a1 = -2 * cosw0,\n           a2 = 1 - alpha;\n           break;\n\t       case \"HP\":\n           var w0 = 2 * Math.PI * _cutoff / sr,\n               sinw0 = Math.sin(w0),\n               cosw0 = Math.cos(w0),\n               alpha = sinw0 / (2 * _Q);\n           b0 = (1 + cosw0) / 2,\n           b1 = -(1 + cosw0),\n           b2 = b0,\n           a0 = 1 + alpha,\n           a1 = -2 * cosw0,\n           a2 = 1 - alpha;\n           break;\n\t       case \"BP\":\n           var w0 = 2 * Math.PI * _cutoff / sr,\n               sinw0 = Math.sin(w0),\n               cosw0 = Math.cos(w0),\n               toSinh = Math.log(2) / 2 * _Q * w0 / sinw0,\n               alpha = sinw0 * (Math.exp(toSinh) - Math.exp(-toSinh)) / 2;\n           b0 = alpha,\n           b1 = 0,\n           b2 = -alpha,\n           a0 = 1 + alpha,\n           a1 = -2 * cosw0,\n           a2 = 1 - alpha;\n           break;\n\t       default:\n           return;\n       }\n\n       b0 = b0 / a0;\n       b1 = b1 / a0;\n       b2 = b2 / a0;\n       a1 = a1 / a0;\n       a2 = a2 / a0;\n       \n    },\n\n    callback: function( x ) {\n      var channels = isNaN( x ) ? 2 : 1,\n          outL = 0,\n          outR = 0,\n          inL = channels === 1 ? x : x[0];\n      \n      //if( _phase++ % 22050 === 0 ) console.log( \"X IS \", typeof x )\n\n      outL = b0 * inL + b1 * x1L + b2 * x2L - a1 * y1L - a2 * y2L;\n\n      x2L = x1L;\n      x1L = inL;\n      y2L = y1L;\n      y1L = outL;\n\n      if(channels === 2) {\n        inR = x[1];\n        outR = b0 * inR + b1 * x1R + b2 * x2R - a1 * y1R - a2 * y2R;\n        x2R = x1R;\n        x1R = inR;\n        y2R = y1R;\n        y1R = outR;\n\n        out[0] = outL;\n        out[1] = outR;\n      }\n      return channels === 1 ? outL : out;\n    },\n\t})\n  .init();\n\n  Object.defineProperties(this, {\n    mode : {\n      get: function() { return _mode; },\n      set: function(v) { _mode = v; this.calculateCoefficients(); }\n    },\n    cutoff : {\n      get: function() { return _cutoff; },\n      set: function(v) { _cutoff = v; this.calculateCoefficients(); }\n    },\n    Q : {\n      get: function() { return _Q; },\n      set: function(v) { _Q = v; this.calculateCoefficients(); }\n    },\n  })\n  \n  this.processProperties(arguments);\n  \n  this.calculateCoefficients();\n};\nGibberish.Biquad.prototype = Gibberish._effect;\n\n/**#Gibberish.Flanger - FX\nClassic flanging effect with feedback.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Flanger({input:a, rate:.5, amount:125, feedback:.5}).connect();  \na.note(440);  \na.feedback = 0;  \na.note(440);  \na.rate = 4;\na.note(440);\n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Flanger.input : property  \nObject. The ugen that should feed the flagner.\n**/\n/**###Gibberish.Flanger.rate : property  \nNumber. The speed at which the delay line tap position is modulated.\n**/\n/**###Gibberish.Flanger.amount : property  \nNumber. The amount of time, in samples, that the delay line tap position varies by.\n**/\n/**###Gibberish.Flanger.feedback : property  \nNumber. The amount of output that should be fed back into the delay line\n**/\n/**###Gibberish.Flanger.offset : property  \nNumber. The base offset of the delay line tap from the current time. Large values (> 500) lead to chorusing effects.\n**/\n\nGibberish.Flanger = function() {\n\tvar buffers =\t        [ new Float32Array(88200), new Float32Array(88200) ],\n\t    bufferLength =    88200,\n\t    delayModulation =\tnew Gibberish.Sine().callback,\n\t    interpolate =\t\t  Gibberish.interpolate,\n\t    readIndex =\t\t\t  -100,\n\t    writeIndex = \t\t  0,\n\t    phase =\t\t\t\t    0;\n      \n\tGibberish.extend(this, {\n    name:\"flanger\",\n    properties:{ input:0, rate:.25, feedback:0, amount:125, offset:125 },\n    \n    callback : function(sample, delayModulationRate, feedback, delayModulationAmount, offset) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      \n  \t\tvar delayIndex = readIndex + delayModulation( delayModulationRate, delayModulationAmount * .95 );\n\n  \t\tif(delayIndex > bufferLength) {\n  \t\t\tdelayIndex -= bufferLength;\n  \t\t}else if(delayIndex < 0) {\n  \t\t\tdelayIndex += bufferLength;\n  \t\t}\n\t\t\t\t\t\n\t\t\tvar delayedSample = interpolate(buffers[0], delayIndex);\n\t\t\tbuffers[0][writeIndex] = channels === 1 ? sample + (delayedSample * feedback): sample[0] + (delayedSample * feedback);\n\t\t\t\t\n      if(channels === 2) {\n        sample[0] += delayedSample;\n        \n  \t\t\tdelayedSample = interpolate(buffers[1], delayIndex);\n  \t\t\tbuffers[1][writeIndex] = sample[1] + (delayedSample * feedback);\n        \n        sample[1] += delayedSample;\n      }else{\n        sample += delayedSample;\n      }\n\t\t\t\n  \t\tif(++writeIndex >= bufferLength) writeIndex = 0;\n  \t\tif(++readIndex  >= bufferLength) readIndex  = 0;\n\n  \t\treturn sample;\n  \t},\t\n  })\n  .init()\n  .processProperties(arguments);\n\n\treadIndex = this.offset * -1;\n};\nGibberish.Flanger.prototype = Gibberish._effect;\n\n/**#Gibberish.Vibrato - FX\nDelay line vibrato effect.\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:44, decay:44100 });  \nb = new Gibberish.Vibrato({input:a, rate:4, amount:125 }).connect();  \na.note(440);  \na.rate = .5;\na.note(440);\n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Vibrato.input : property  \nObject. The ugen that should feed the vibrato.\n**/\n/**###Gibberish.Vibrato.rate : property  \nNumber. The speed at which the delay line tap position is modulated.\n**/\n/**###Gibberish.Vibrato.amount : property  \nNumber. The size of the delay line modulation; effectively the amount of vibrato to produce, \n**/\n/**###Gibberish.Vibrato.offset : property  \nNumber. The base offset of the delay line tap from the current time.\n**/\nGibberish.Vibrato = function() {\n\tvar buffers =\t        [ new Float32Array(88200), new Float32Array(88200) ],\n\t    bufferLength =    88200,\n\t    delayModulation =\tnew Gibberish.Sine().callback,\n\t    interpolate =\t\t  Gibberish.interpolate,\n\t    readIndex =\t\t\t  -100,\n\t    writeIndex = \t\t  0,\n\t    phase =\t\t\t\t    0;\n      \n\tGibberish.extend(this, {\n    name:\"vibrato\",\n  \tproperties:{ input:0, rate:5, amount:.5, offset:125 },\n    \n  \tcallback : function(sample, delayModulationRate, delayModulationAmount, offset) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      \n  \t\tvar delayIndex = readIndex + delayModulation( delayModulationRate, delayModulationAmount * offset - 1 );\n\n  \t\tif(delayIndex > bufferLength) {\n  \t\t\tdelayIndex -= bufferLength;\n  \t\t}else if(delayIndex < 0) {\n  \t\t\tdelayIndex += bufferLength;\n  \t\t}\n\t\t\t\t\t\n\t\t\tvar delayedSample = interpolate(buffers[0], delayIndex);\n\t\t\tbuffers[0][writeIndex] = channels === 1 ? sample : sample[0];\n\t\t\t\t\n      if(channels === 2) {\n        sample[0] = delayedSample;\n        \n  \t\t\tdelayedSample = interpolate(buffers[1], delayIndex);\n  \t\t\tbuffers[1][writeIndex] = sample[1];\n        \n        sample[1] = delayedSample;\n      }else{\n        sample = delayedSample;\n      }\n\t\t\t\n  \t\tif(++writeIndex >= bufferLength) writeIndex = 0;\n  \t\tif(++readIndex  >= bufferLength) readIndex  = 0;\n\n  \t\treturn sample;\n  \t},\t\n  })\n  .init()\n  .processProperties(arguments);\n\n\treadIndex = this.offset * -1;\n};\nGibberish.Vibrato.prototype = Gibberish._effect;\n\n/**#Gibberish.BufferShuffler - FX\nA buffer shuffling / stuttering effect with reversing and pitch-shifting\n\n## Example Usage##\n`a = new Gibberish.Synth({ attack:88200, decay:88200 });  \nb = new Gibberish.BufferShuffler({input:a, chance:.25, amount:125, rate:44100, pitchMin:-4, pitchMax:4 }).connect();  \na.note(440);\n`  \n##Constructor##\n**param** *properties* : Object. A dictionary of property keys and values to assign to the Gibberish.BufferShuffler object\n- - - - \n**/\n/**###Gibberish.BufferShuffler.chance : property\nFloat. Range 0..1. Default .25. The likelihood that incoming audio will be shuffled.\n**/\n/**###Gibberish.BufferShuffler.rate : property\nInteger, in samples. Default 11025. How often Gibberish.BufferShuffler will randomly decide whether or not to shuffle.\n**/\n/**###Gibberish.BufferShuffler.length : property\nInteger, in samples. Default 22050. The length of time to play stuttered audio when stuttering occurs.\n**/\n/**###Gibberish.BufferShuffler.reverseChance : property\nFloat. Range 0..1. Default .5. The likelihood that stuttered audio will be reversed\n**/\n/**###Gibberish.BufferShuffler.pitchChance : property\nFloat. Range 0..1. Default .5. The likelihood that stuttered audio will be repitched.\n**/\n/**###Gibberish.BufferShuffler.pitchMin : property\nFloat. Range 0..1. Default .25. The lowest playback speed used to repitch the audio\n**/\n/**###Gibberish.BufferShuffler.pitchMax : property\nFloat. Range 0..1. Default 2. The highest playback speed used to repitch the audio.\n**/\n/**###Gibberish.BufferShuffler.wet : property\nFloat. Range 0..1. Default 1. When shuffling, the amplitude of the wet signal\n**/\n/**###Gibberish.BufferShuffler.dry : property\nFloat. Range 0..1. Default 0. When shuffling, the amplitude of the dry signal\n**/\n\nGibberish.BufferShuffler = function() {\n\tvar buffers = [ new Float32Array(88200), new Float32Array(88200) ],\n    \tbufferLength = 88200,  \n  \t\treadIndex = 0,\n  \t\twriteIndex = 0,\n  \t\trandomizeCheckIndex = 0,\n  \t\tshuffleTimeKeeper = 0,\n  \t\tisShuffling = 0,\n  \t\trandom = Math.random,\n  \t\tfadeIndex = 0,\n  \t\tfadeAmount = 1,\n  \t\tisFadingWetIn = false,\n  \t\tisFadingDryIn = false,\n  \t\treversed = false,\n  \t\tinterpolate = Gibberish.interpolate,\n  \t\tpitchShifting = false,\n  \t\tspeed = 1,\n  \t\tisBufferFull = false,\n      rndf = Gibberish.rndf,\n      _output = [0,0];\n\t\n\tGibberish.extend(this, {\n    name:\"buffer_shuffler\",\n\t\n  \tproperties: { input:0, chance:.25, rate:11025, length:22050, reverseChange:.5, pitchChance:.5, pitchMin:.25, pitchMax:2, wet:1, dry:0 },\n\n  \tcallback : function(sample, chance, rate, length, reverseChance, pitchChance, pitchMin, pitchMax, wet, dry) {\n      var channels = typeof sample === 'number' ? 1 : 2;\n      \n  \t\tif(!isShuffling) {\n        buffers[0][writeIndex] = channels === 1 ? sample : sample[0];\n        buffers[1][writeIndex] = channels === 1 ? sample : sample[1]; // won't be used but with one handle but probably cheaper than an if statement?\n                \n  \t\t\twriteIndex++\n  \t\t\twriteIndex %= bufferLength;\n\n  \t\t\tisBufferFull = writeIndex === 0 ? 1 : isBufferFull; // don't output buffered audio until a buffer is full... otherwise you just get a gap\n\t\t\t\t\t\t\n  \t\t\trandomizeCheckIndex++;\n\n  \t\t\tif(randomizeCheckIndex % rate == 0 && random() < chance) {\n  \t\t\t\treversed = random() < reverseChance;\n  \t\t\t\tisShuffling = true;\n  \t\t\t\tif(!reversed) {\n  \t\t\t\t\treadIndex = writeIndex - length;\n  \t\t\t\t\tif(readIndex < 0) readIndex = bufferLength + readIndex;\n  \t\t\t\t}\n  \t\t\t\tpitchShifting = random() < pitchChance;\n  \t\t\t\tif(pitchShifting) {\n  \t\t\t\t\tspeed = rndf(pitchMin, pitchMax);\n  \t\t\t\t}\n  \t\t\t\tfadeAmount = 1;\n  \t\t\t\tisFadingWetIn = true;\n  \t\t\t\tisFadingDryIn = false;\n  \t\t\t}\n  \t\t}else if(++shuffleTimeKeeper % (length - 400) === 0) {\n  \t\t\tisFadingWetIn = false;\n  \t\t\tisFadingDryIn = true;\n  \t\t\tfadeAmount = 1;\n  \t\t\tshuffleTimeKeeper = 0;\n  \t\t}\n\t\t\t\t\t\n  \t\treadIndex += reversed ? speed * -1 : speed;\n  \t\tif(readIndex < 0) {\n  \t\t\treadIndex += bufferLength;\n  \t\t}else if( readIndex >= bufferLength ) {\n  \t\t\treadIndex -= bufferLength;\n  \t\t}\t\n  \t\tvar outSampleL = interpolate(buffers[0], readIndex);\n\t\t\t\n      var outL, outR, shuffle, outSampleR;\t\t\t\n\t\t\tif(isFadingWetIn) {\t\t\t\t\t\t\n\t\t\t\tfadeAmount -= .0025;\n        \n        shuffle = (outSampleL * (1 - fadeAmount));\n\t\t\t\toutL = channels === 1 ? shuffle + (sample * fadeAmount) : shuffle + (sample[0] * fadeAmount);\n        \n        if(channels === 2) {\n          outSampleR = interpolate(buffers[1], readIndex);\n          shuffle = (outSampleR * (1 - fadeAmount));\n          outR = channels === 1 ? outL : shuffle + (sample[1] * fadeAmount);\n        }\n\n\t\t\t\tif(fadeAmount <= .0025) isFadingWetIn = false;\n\t\t\t}else if(isFadingDryIn) {\t\t\t\t\t\t\n\t\t\t\tfadeAmount -= .0025;\n        \n        shuffle = outSampleL * fadeAmount;\n\t\t\t\toutL = channels === 1 ? shuffle + (sample * fadeAmount) : shuffle + (sample[0] * (1 - fadeAmount));\n        \n        if(channels === 2) {\n          outSampleR = interpolate(buffers[1], readIndex);\n          shuffle = outSampleR * fadeAmount;\n          outR = shuffle + (sample[1] * (1 - fadeAmount));\n        }\n        \n\t\t\t\tif(fadeAmount <= .0025) { \n\t\t\t\t\tisFadingDryIn = false;\n\t\t\t\t\tisShuffling = false;\n\t\t\t\t\treversed = false;\n\t\t\t\t\tspeed = 1;\n\t\t\t\t\tpitchShifting = 0;\n\t\t\t\t}\n\t\t\t}else{\n        if(channels === 1) {\n          outL = isShuffling && isBufferFull ? (outSampleL * wet) + sample * dry : sample;\n        }else{\n          outSampleR = interpolate(buffers[1], readIndex);\n          outL = isShuffling && isBufferFull ? (outSampleL * wet) + sample[0] * dry : sample[0];\n          outR = isShuffling && isBufferFull ? (outSampleR * wet) + sample[1] * dry : sample[1];          \n        }\n\t\t\t}\n      _output = [outL, outR];\n  \t\treturn channels === 1 ? outL : _output;\n  \t},\n  })\n  .init()\n  .processProperties(arguments);\n};\nGibberish.BufferShuffler.prototype = Gibberish._effect;\n\nGibberish.AllPass = function(time, feedback) {\n\tvar index  = -1,\n    \tbuffer =\tnew Float32Array(time || 500),\n      bufferLength = buffer.length;\n  \n  Gibberish.extend(this, {\n\t\tname:\t\t\"allpass\",\n    properties: {\n      input   : 0,\n    },\n    callback : function(sample) {\n  \t\tindex = ++index % bufferLength;\n  \t\tvar bufferSample = buffer[index];\n  \t\tvar out = -1 * sample + bufferSample;\n\n  \t\tbuffer[index] = sample + (bufferSample * .5);\n  \t\treturn out;\n  \t},\n\t});\n  \n};\n/*\nadapted from audioLib.js, in turn adapted from Freeverb source code\nthis is actually a lowpass-feedback-comb filter (https://ccrma.stanford.edu/~jos/pasp/Lowpass_Feedback_Comb_Filter.html)\n*/\nGibberish.Comb = function(time) {\n\tvar buffer = new Float32Array(time || 1200),\n    \tbufferLength = buffer.length,\n    \tindex = 0,\n    \tstore = 0;\n      \n\tGibberish.extend(this, {\n\t\tname:\t\t\"comb\",\n    properties : {\n      input : 0,\n      feedback : .84,\n      damping: .2,\n  \t\t//time:\t\ttime || 1200,\n    },\n    \n    /*\n\t\tself.sample\t= self.buffer[self.index];\n\t\tself.store\t= self.sample * self.invDamping + self.store * self.damping;\n\t\tself.buffer[self.index++] = s + self.store * self.feedback;\n    */\n    \n  \tcallback: function(sample, feedback, damping) {\n  \t\tvar currentPos = ++index % bufferLength;\n\t\t\tvar out = buffer[currentPos];\n\t\t\t\t\t\t\n\t\t\tstore = (out * (1 - damping)) + (store * damping);\n\t\t\t\t\t\t\n\t\t\tbuffer[currentPos] = sample + (store * feedback);\n\n  \t\treturn out;\n  \t},\n\t});\n  \n};\n\n/**#Gibberish.Reverb - FX\nbased off audiolib.js reverb and freeverb\n \n## Example Usage##\n`a = new Gibberish.Synth({ attack:88200, decay:88200 });  \nb = new Gibberish.Reverb({input:a, roomSize:.5, wet:1, dry;.25}).connect();\na.note(440);\n`  \n##Constructor\n**param** *properties* : Object. A dictionary of property keys and values to assign to the Gibberish.BufferShuffler object\n**/\n/**###Gibberish.Reverb.roomSize : property\nFloat. 0..1. The size of the room being emulated.\n**/\t\n/**###Gibberish.Reverb.damping : property\nFloat. Attenuation of high frequencies that occurs.\n**/\t\n/**###Gibberish.Reverb.wet : property\nFloat. Default = .75. The amount of processed signal that is output.  \n**/\t\n/**###Gibberish.Reverb.dry : property\nFloat. Default = .5. The amount of dry signal that is output\n**/\t\n\nGibberish.Reverb = function() {\n  var tuning =\t{\n\t\t    combCount: \t\t    8,\n\t\t    combTuning: \t    [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617],\n                          \n\t\t    allPassCount: \t  4,\n\t\t    allPassTuning: \t  [556, 441, 341, 225],\n\t\t    allPassFeedback:  0.5,\n                          \n\t\t    fixedGain: \t\t    0.015,\n\t\t    scaleDamping: \t  0.4,\n                          \n\t\t    scaleRoom: \t\t    0.28,\n\t\t    offsetRoom: \t    0.7,\n                          \n\t\t    stereoSpread: \t  23\n\t\t},\n    feedback = .84,\n    combs = [],\n    apfs  = [],\n    output   = [0,0],\n    phase  = 0;\n    \n\tGibberish.extend(this, {\n\t\tname:\t\t\"reverb\",\n    \n\t\troomSize:\t.5,\n    \n    properties: {\n      input:    0,\n  \t\twet:\t\t  .5,\n  \t\tdry:\t\t  .55,\n      roomSize: .84,\n      damping:  .5,\n    },\n    \n    callback : function(sample, wet, dry, roomSize, damping) {\n      var channels = typeof sample === 'object' ? 2 : 1;\n      \n\t\t\tvar input = channels === 1 ? sample : sample[0] + sample[1]; // converted to fake stereo\n\n\t\t\tvar _out = input * .015;\n      var out = _out;\n\t\t\t\t\t\t\n\t\t\tfor(var i = 0; i < 8; i++) {\n\t\t\t\tvar filt = combs[i](_out, roomSize * .98, (damping * .4)); // .98 is scaleRoom + offsetRoom, .4 is scaleDamping\n\t\t\t\tout += filt;\t\t\t\t\n\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\tfor(var i = 0; i < 4; i++) {\n\t\t\t\tout = apfs[i](out);\t\n\t\t\t}\n      \n      output[0] = output[1] = (input * dry) + (out * wet);\n\n  \t\treturn output;\n  \t},\n\t})  \n  .init()\n  .processProperties(arguments);\n      \n  this.setFeedback = function(v) { feedback = v }\n  \n\tfor(var i = 0; i < 8; i++){\n\t\tcombs.push( new Gibberish.Comb( tuning.combTuning[i] ).callback );\n\t}\n  \n\tfor(var i = 0; i < 4; i++){\n\t\tapfs.push( new Gibberish.AllPass(tuning.allPassTuning[i], tuning.allPassFeedback ).callback );\n\t}\n\n};\nGibberish.Reverb.prototype = Gibberish._effect;\n\n/**#Gibberish.StereoReverb - FX\nstereo version of the reverb effect\n \n## Example Usage##\n`a = new Gibberish.Synth({ attack:88200, decay:88200, pan:-1 });  \nb = new Gibberish.StereoReverb({input:a, roomSize:.5, wet:1, dry;.25}).connect();\na.note(440);\n`  \n##Constructor\n**param** *properties* : Object. A dictionary of property keys and values to assign to the Gibberish.BufferShuffler object\n**/\n/**###Gibberish.Reverb.roomSize : property\nFloat. 0..1. The size of the room being emulated.\n**/\t\n/**###Gibberish.Reverb.damping : property\nFloat. Attenuation of high frequencies that occurs.\n**/\t\n/**###Gibberish.Reverb.wet : property\nFloat. Default = .75. The amount of processed signal that is output.  \n**/\t\n/**###Gibberish.Reverb.dry : property\nFloat. Default = .5. The amount of dry signal that is output\n**/\t\nGibberish.StereoReverb = function() {\n  var tuning =\t{\n\t\t    combCount: \t\t    8,\n\t\t    combTuning: \t    [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617],\n                          \n\t\t    allPassCount: \t  4,\n\t\t    allPassTuning: \t  [556, 441, 341, 225],\n\t\t    allPassFeedback:  0.5,\n                          \n\t\t    fixedGain: \t\t    0.015,\n\t\t    scaleDamping: \t  0.4,\n                          \n\t\t    scaleRoom: \t\t    0.28,\n\t\t    offsetRoom: \t    0.7,\n                          \n\t\t    stereoSpread: \t  23\n\t\t},\n    feedback = .84,\n    combsL = [], combsR = [],\n    apfsL  = [], apfsR = [],\n    output   = [0,0],\n    phase  = 0;\n    \n\tGibberish.extend(this, {\n\t\tname:\t\t\"reverb\",\n    \n\t\troomSize:\t.5,\n    \n    properties: {\n      input:    0,\n  \t\twet:\t\t  .5,\n  \t\tdry:\t\t  .55,\n      roomSize: .84,\n      damping:  .5,\n    },\n    \n    callback : function(sample, wet, dry, roomSize, damping) {\n      var channels = typeof sample === 'object' ? 2 : 1,\n          l = sample[0],\n          r = channels === 1 ? l : sample[1],\n          _outL = outL = l * .015,\n          _outR = outR = r * .015;\n\t\t\t\t\t\t\n\t\t\tfor(var i = 0; i < 8; i++) { // parallel\n\t\t\t\toutL += combsL[ i ]( _outL, roomSize * .98, (damping * .4)); // .98 is scaleRoom + offsetRoom, .4 is scaleDamping\n        outR += combsR[ i ]( _outR, roomSize * .98, (damping * .4));       \n\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\tfor(var i = 0; i < 4; i++) {\n\t\t\t\toutL = apfsL[ i ]( outL );\t\n\t\t\t\toutR = apfsR[ i ]( outR );\t        \n\t\t\t}\n      \n      output[0] = (l * dry) + (outL * wet);\n      output[1] = (r * dry) + (outR * wet);\n\n  \t\treturn output;\n  \t},\n\t})  \n  .init()\n  .processProperties(arguments);\n      \n  this.setFeedback = function(v) { feedback = v }\n  \n\tfor(var i = 0; i < 8; i++){\n\t\tcombsL.push( new Gibberish.Comb( tuning.combTuning[i] ).callback );\n    combsR.push( new Gibberish.Comb( tuning.combTuning[i] ).callback );\n\t}\n  \n\tfor(var i = 0; i < 4; i++){\n\t\tapfsL.push( new Gibberish.AllPass(tuning.allPassTuning[i], tuning.allPassFeedback ).callback );\n    apfsR.push( new Gibberish.AllPass(tuning.allPassTuning[i], tuning.allPassFeedback ).callback );    \n\t}\n};\nGibberish.StereoReverb.prototype = Gibberish._effect;\n\n/**#Gibberish.Granulator - FX\nA granulator that operates on a buffer of samples. You can get the samples from a [Sampler](javascript:displayDocs('Gibberish.Sampler'\\))\nobject.\n\n## Example Usage ##\n`a = new Gibberish.Sampler('resources/trumpet.wav');  \n// wait until sample is loaded to create granulator  \na.onload = function() {  \n  b = new Gibberish.Granulator({  \n    buffer:a.getBuffer(),  \n    grainSize:1000,  \n    speedMin: -2,  \n    speedMax: 2,  \n  });  \n  b.mod('position', new Gibberish.Sine(.1, .45), '+');  \n  b.connect();  \n};`\n## Constructor\n**param** *propertiesList*: Object. At a minimum you should define the input to granulate. See the example.\n**/\n/**###Gibberish.Granulator.speed : property\nFloat. The playback rate, in samples, of each grain\n**/\n/**###Gibberish.Granulator.speedMin : property\nFloat. When set, the playback rate will vary on a per grain basis from (grain.speed + grain.speedMin) -> (grain.speed + grain.speedMax). This value should almost always be negative.\n**/\n/**###Gibberish.Granulator.speedMax : property\nFloat. When set, the playback rate will vary on a per grain basis from (grain.speed + grain.speedMin) -> (grain.speed + grain.speedMax).\n**/\n/**###Gibberish.Granulator.grainSize : property\nInteger. The length, in samples, of each grain\n**/\n/**###Gibberish.Granulator.position : property\nFloat. The center position of the grain cloud. 0 represents the start of the buffer, 1 represents the end.\n**/\n/**###Gibberish.Granulator.positionMin : property\nFloat. The left boundary on the time axis of the grain cloud.\n**/\n/**###Gibberish.Granulator.positionMax : property\nFloat. The right boundary on the time axis of the grain cloud.\n**/\n/**###Gibberish.Granulator.buffer : property\nObject. The input buffer to granulate.\n**/\n/**###Gibberish.Granulator.numberOfGrains : property\nFloat. The number of grains in the cloud. Can currently only be set on initialization.\n**/\n\nGibberish.Granulator = function(properties) {\n\tvar grains      = [];\n\t    buffer      = null,\n\t    interpolate = Gibberish.interpolate,\n      panner      = Gibberish.makePanner(),\n      bufferLength= 0,\n\t    debug       = 0,\n\t    write       = 0,\n      self        = this,\n      out         = [0,0],\n      _out        = [0,0],\n      rndf        = Gibberish.rndf,\n      numberOfGrains = properties.numberOfGrains || 20;\n  \n      console.log( \"NUMBER OF GRAINS\", numberOfGrains )\n  \n\tGibberish.extend(this, { \n\t\tname:\t\t        \"granulator\",\n\t\tbufferLength:   88200,\n\t\treverse:\t      true,\n\t\tspread:\t\t      .5,\n    \n    properties : {\n      speed: \t\t    1,\n      speedMin:     -0,\n      speedMax: \t  .0,\n      grainSize: \t  1000,\n      position:\t    .5,\n      positionMin:  0,\n      positionMax:  0,\n      amp:\t\t      .2,\n      fade:\t\t      .1,\n      pan:\t\t      0,\n      shouldWrite:  false,\n    },\n    \n    setBuffer : function(b) { buffer = b; bufferLength = b.length },\n    \n    callback : function(speed, speedMin, speedMax, grainSize, positionMin, positionMax, position, amp, fade, pan, shouldWrite) {\n    \t\tfor(var i = 0; i < numberOfGrains; i++) {\n    \t\t\tvar grain = grains[i];\n\t\t\t\t\t\n    \t\t\tif(grain._speed > 0) {\n    \t\t\t\tif(grain.pos > grain.end) {\n    \t\t\t\t\tgrain.pos = (position + rndf(positionMin, positionMax)) * buffer.length;\n    \t\t\t\t\tgrain.start = grain.pos;\n    \t\t\t\t\tgrain.end = grain.start + grainSize;\n    \t\t\t\t\tgrain._speed = speed + rndf(speedMin, speedMax);\n    \t\t\t\t\tgrain._speed = grain._speed < .1 ? .1 : grain._speed;\n    \t\t\t\t\tgrain._speed = grain._speed < .1 && grain._speed > 0 ? .1 : grain._speed;\t\t\t\t\t\t\t\n    \t\t\t\t\tgrain._speed = grain._speed > -.1 && grain._speed < 0 ? -.1 : grain._speed;\t\t\t\t\t\t\t\n    \t\t\t\t\tgrain.fadeAmount = grain._speed * (fade * grainSize);\n    \t\t\t\t\tgrain.pan = rndf(self.spread * -1, self.spread);\n    \t\t\t\t}\n\t\t\t\t\t\t\n    \t\t\t\tvar _pos = grain.pos;\n    \t\t\t\twhile(_pos > buffer.length) _pos -= buffer.length;\n    \t\t\t\twhile(_pos < 0) _pos += buffer.length;\n\t\t\t\t\t\t\n    \t\t\t\tvar _val = interpolate(buffer, _pos);\n\t\t\t\t\t\n    \t\t\t\t_val *= grain.pos < grain.fadeAmount + grain.start ? (grain.pos - grain.start) / grain.fadeAmount : 1;\n    \t\t\t\t_val *= grain.pos > (grain.end - grain.fadeAmount) ? (grain.end - grain.pos)   / grain.fadeAmount : 1;\n\t\t\t\t\t\t\n    \t\t\t}else {\n    \t\t\t\tif(grain.pos < grain.end) {\n    \t\t\t\t\tgrain.pos = (position + rndf(positionMin, positionMax)) * buffer.length;\n    \t\t\t\t\tgrain.start = grain.pos;\n    \t\t\t\t\tgrain.end = grain.start - grainSize;\n    \t\t\t\t\tgrain._speed = speed + rndf(speedMin, speedMax);\n    \t\t\t\t\tgrain._speed = grain._speed < .1 && grain._speed > 0 ? .1 : grain._speed;\t\t\t\t\t\t\t\n    \t\t\t\t\tgrain._speed = grain._speed > -.1 && grain._speed < 0 ? -.1 : grain._speed;\t\n    \t\t\t\t\tgrain.fadeAmount = grain._speed * (fade * grainSize);\t\t\t\t\t\t\t\n    \t\t\t\t}\n\t\t\t\t\t\t\n    \t\t\t\tvar _pos = grain.pos;\n    \t\t\t\twhile(_pos > buffer.length) _pos -= buffer.length;\n    \t\t\t\twhile(_pos < 0) _pos += buffer.length;\n\t\t\t\t\t\n    \t\t\t\tvar _val = interpolate(buffer, _pos);\n\t\t\t\t\t\n    \t\t\t\t_val *= grain.pos > grain.start - grain.fadeAmount ? (grain.start - grain.pos) / grain.fadeAmount : 1;\n    \t\t\t\t_val *= grain.pos < (grain.end + grain.fadeAmount) ? (grain.end - grain.pos) / grain.fadeAmount : 1;\n    \t\t\t}\n\t\t\t\t\t\n    \t\t\t_out = panner(_val * amp, grain.pan, _out);\n          out[0] += _out[0];\n          out[1] += _out[1];\n    \t\t\t\n          grain.pos += grain._speed;\n    \t\t}\n\t\t\t\t\n    \t\treturn panner(out, pan, out);\n    \t},\n\t})\n  .init()\n  .processProperties(arguments);\n  \n  \n  \n\tfor(var i = 0; i < numberOfGrains; i++) {\n\t\tgrains[i] = {\n\t\t\tpos : self.position + Gibberish.rndf(self.positionMin, self.positionMax),\n\t\t\t_speed : self.speed + Gibberish.rndf(self.speedMin, self.speedMax),\n\t\t}\n\t\tgrains[i].start = grains[i].pos;\n\t\tgrains[i].end = grains[i].pos + self.grainSize;\n\t\tgrains[i].fadeAmount = grains[i]._speed * (self.fade * self.grainSize);\n\t\tgrains[i].pan = Gibberish.rndf(self.spread * -1, self.spread);\n    \n    console.log( \"GRAIN\", i, \"POS\", grains[i].pos, \"SPEED\", grains[i]._speed )\n\t}\n  \n  this.grains = grains\n\t\t\t\n\t/*if(typeof properties.input !== \"undefined\") { \n\t\t\tthis.shouldWrite = true;\n      \n\t\t\tthis.sampler = new Gibberish.Sampler();\n\t\t\tthis.sampler.connect();\n\t\t\tthis.sampler.record(properties.buffer, this.bufferLength);\n      \n\t\t\tbuffer = this.sampler.buffer;\n\t}else*/ if(typeof properties.buffer !== 'undefined') {\n\t  buffer = properties.buffer;\n    bufferLength = buffer.length;\n\t}\n\n};\nGibberish.Granulator.prototype = Gibberish._effect;\nGibberish.synth = function() {\n  this.type = 'oscillator';\n    \n  this.oscillatorInit = function() {\n    this.fx = new Array2; \n    this.fx.parent = this;\n  };\n};\nGibberish.synth.prototype = new Gibberish.ugen();\nGibberish._synth = new Gibberish.synth();\n\n/**#Gibberish.Synth - Synth\nOscillator + attack / decay envelope.\n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \na.note(880);  \na.waveform = \"Triangle\";  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Synth.frequency : property  \nNumber. The frequency for the carrier oscillator. This is normally set using the note method but can also be modulated.\n**/\n/**###Gibberish.Synth.pulsewidth : property  \nNumber. The duty cycle for PWM synthesis\n**/\n/**###Gibberish.Synth.attack : property  \nNumber. The length of the attack portion of the envelope in samples. Note that the synth's envelope affects both amplitude and the index of the synth.\n**/\n/**###Gibberish.Synth.decay : property  \nNumber. The length of the decay portion of the envelope in samples. Note that the synth's envelope affects both amplitude and the index of the synth.\n**/\n/**###Gibberish.Synth.glide : property  \nNumber. The synth has a one-pole filter attached to the carrier frequency. Set glide to a value between .999 and 1 to get pitch sweep between notes.\n**/\n/**###Gibberish.Synth.amp : property  \nNumber. The relative amplitude level of the synth.\n**/\n/**###Gibberish.Synth.channels : property  \nNumber. Default 2. Mono or Stereo synthesis.\n**/\n/**###Gibberish.Synth.pan : property  \nNumber. Default 0. If the synth has two channels, this determines its position in the stereo spectrum.\n**/\n/**###Gibberish.Synth.waveform : property  \nString. The type of waveform to use. Options include 'Sine', 'Triangle', 'PWM', 'Saw' etc.\n**/\n\t\t\nGibberish.Synth = function(properties) {\n\tthis.name =\t\"synth\";\n\n\tthis.properties = {\n\t  frequency:0,\n    pulsewidth:.5,\n\t  attack:\t\t22050,\n\t  decay:\t\t22050,\n    sustain:  22050,\n    release:  22050,\n    attackLevel: 1,\n    sustainLevel: .5,\n    releaseTrigger: 0,\n    glide:    .15,\n    amp:\t\t  .25,\n    channels: 2,\n\t  pan:\t\t  0,\n    velocity: 1,\n    sr:       Gibberish.context.sampleRate,\n  };\n/**###Gibberish.Synth.note : method  \nGenerate an enveloped note at the provided frequency  \n  \nparam **frequency** Number. The frequency for the oscillator.  \nparam **amp** Number. Optional. The volume to use.  \n**/    \n\tthis.note = function(frequency, velocity) {\n    if( typeof frequency === 'undefined' ) return\n    if( Array.isArray( arguments[0] ) ) {\n      var tmp  = arguments[0][0]\n      velocity = arguments[0][1]\n      frequency = tmp\n    }\n\n\n    if( velocity !== 0 ) {\n  \t\tif( typeof this.frequency !== 'object' ){\n        if( useADSR && frequency === lastFrequency && properties.requireReleaseTrigger ) {\n          this.releaseTrigger = 1;\n          lastFrequency = null\n          return;\n        }\n        \n        this.frequency = lastFrequency = frequency;\n        this.releaseTrigger = 0;\n        \n        if( typeof frequency === 'object' ) {\n          Gibberish.dirty( this )\n        }\n      }else{\n        this.frequency[0] = lastFrequency = frequency;\n        this.releaseTrigger = 0;\n        Gibberish.dirty(this);\n      }\n\t\t\t\t\t\n      if( typeof velocity !== 'undefined') {\n        this.velocity = velocity;\n      }\n      _envelope.run();\n    }else{\n      this.releaseTrigger = 1;\n    }\n\t};\n  \n  properties = properties || {}\n  \n\tvar useADSR     = typeof properties.useADSR === 'undefined' ? false : properties.useADSR,\n      _envelope   = useADSR ? new Gibberish.ADSR() : new Gibberish.AD(),\n      envstate    = _envelope.getState,\n      envelope    = _envelope.callback,\n      _osc        = new Gibberish.PWM(),\n\t    osc         = _osc.callback,\n      lag         = new Gibberish.OnePole().callback,\n    \tpanner      = Gibberish.makePanner(),\n      obj         = this,\n      lastFrequency = 0,\n      phase = 0,\n    \tout         = [0,0];\n      \n  _envelope.requireReleaseTrigger = properties.requireReleaseTrigger || false;\n      \n  this.callback = function(frequency, pulsewidth, attack, decay, sustain,release,attackLevel,sustainLevel,releaseTrigger, glide, amp, channels, pan, velocity, sr) {\n    glide = glide >= 1 ? .99999 : glide;\n    frequency = lag(frequency, 1-glide, glide);\n    \n    var env, val\n    if( useADSR ) {\n      env = envelope( attack, decay, sustain, release, attackLevel, sustainLevel, releaseTrigger );\n      if( releaseTrigger ) {\n        obj.releaseTrigger = 0\n      }\n\n      if( envstate() < 4 ) {\n  \t\t\tval = osc( frequency, 1, pulsewidth, sr ) * env * velocity *  amp;\n    \n  \t\t\treturn channels === 1 ? val : panner(val, pan, out);\n      }else{\n  \t\t  val = out[0] = out[1] = 0;\n        return channels === 1 ? val : out\n      }\n    }else{\n  \t\tif(envstate() < 2) {\n        env = envelope(attack, decay);\n  \t\t\tval = osc( frequency, 1, pulsewidth, sr ) * env * velocity * amp;\n      \n  \t\t\treturn channels === 1 ? val : panner(val, pan, out);\n      }else{\n  \t\t  val = out[0] = out[1] = 0;\n        return channels === 1 ? val : out\n      }\n    }\n\t};\n  \n  this.getEnv = function() { return _envelope; }\n  this.getOsc = function() { return _osc; };\n  this.setOsc = function(val) { _osc = val; osc = _osc.callback };\n  \n  var waveform = \"PWM\";\n  Object.defineProperty(this, 'waveform', {\n    get : function() { return waveform; },\n    set : function(val) { this.setOsc( new Gibberish[val]() ); }\n  });\n  \n  this.init();\n  this.oscillatorInit();\n\tthis.processProperties(arguments);\n};\nGibberish.Synth.prototype = Gibberish._synth;\n\n/**#Gibberish.PolySynth - Synth\nA polyphonic version of [Synth](javascript:displayDocs('Gibberish.Synth'\\)). There are two additional properties for the polyphonic version of the synth. The polyphonic version consists of multiple Synths being fed into a single [Bus](javascript:displayDocs('Gibberish.Bus'\\)) object.\n  \n## Example Usage ##\n`Gibberish.init();  \na = new Gibberish.PolySytn({ attack:88200, decay:88200, maxVoices:10 }).connect();  \na.note(880);  \na.note(1320); \na.note(1760);  \n`  \n## Constructor   \nOne important property to pass to the constructor is the maxVoices property, which defaults to 5. This controls how many voices are allocated to the synth and cannot be changed after initialization.  \n  \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.PolySynth.children : property  \nArray. Read-only. An array holding all of the child FMSynth objects.\n**/\n/**###Gibberish.PolySynth.maxVoices : property  \nNumber. The number of voices of polyphony the synth has. May only be set in initialization properties passed to constrcutor.\n**/\nGibberish.PolySynth = function() {\n  this.__proto__ = new Gibberish.Bus2();\n  \n  Gibberish.extend(this, {\n    name:     \"polysynth\",\n    maxVoices:    5,\n    voiceCount:   0,\n    frequencies:  [],\n    _frequency: 0,\n    \n    polyProperties : {\n      frequency: 0,\n  \t\tglide:\t\t\t0,\n      attack: 22050,\n      decay:  22050,\n      sustain:22050,\n      release:22050,\n      attackLevel: 1,\n      sustainLevel: .5,      \n      pulsewidth:.5,\n      velocity: 1,\n      waveform:\"PWM\",\n    },\n\n/**###Gibberish.PolySynth.note : method  \nGenerate an enveloped note at the provided frequency using a simple voice allocation system where if all children are active, the one active the longest cancels its current note and begins playing a new one.    \n  \nparam **frequency** Number. The frequency for the oscillator. \nparam **amp** Number. Optional. The volume to use.  \n**/  \n    note : function(_frequency, velocity) {\n      if( typeof _frequency === 'undefined' ) return\n\n      var lastNoteIndex = this.frequencies.indexOf( _frequency ),\n          idx = lastNoteIndex > -1 ? lastNoteIndex : this.voiceCount++,\n          synth = this.children[ idx ];\n\n      synth.note( _frequency, velocity );\n \n      if( lastNoteIndex === -1) {\n        this.frequencies[ idx ] = _frequency;\n        this._frequency = _frequency\n        if(this.voiceCount >= this.maxVoices) this.voiceCount = 0;\n      }else{\n        delete this.frequencies[ idx ]\n      }\n      this.lastChild = idx\n    },\n \n    initVoices: function() {\n      for(var i = 0; i < this.maxVoices; i++) {\n        var props = {\n          waveform: this.waveform,\n    \t\t\tattack: \tthis.attack,\n    \t\t\tdecay:\t\tthis.decay,\n          sustain:  this.sustain,\n          release:  this.release,\n          attackLevel: this.attackLevel,\n          sustainLevel: this.sustainLevel,\n          pulsewidth: this.pulsewidth,\n          channels: 2,\n          amp:      1,\n          useADSR : this.useADSR || false,\n          requireReleaseTrigger: this.requireReleaseTrigger || false,\n        },\n        synth = new Gibberish.Synth( props ).connect( this );\n\n        this.children.push(synth);\n      }\n    },\n  });\n  \n  this.amp = 1 / this.maxVoices;\n    \n  this.children = [];\n  \n  if(typeof arguments[0] === 'object') {\n    this.maxVoices = arguments[0].maxVoices ? arguments[0].maxVoices : this.maxVoices\n    this.useADSR = typeof arguments[0].useADSR !== 'undefined' ? arguments[ 0 ].useADSR : false\n    this.requireReleaseTrigger = typeof arguments[0].requireReleaseTrigger !== 'undefined' ? arguments[ 0 ].requireReleaseTrigger : false    \n  }\n  \n  Gibberish.polyInit(this);\n  this.initVoices()\n  \n  this.processProperties(arguments);\n  \n  Gibberish._synth.oscillatorInit.call(this);\n};\n\n/**#Gibberish.Synth2 - Synth\nOscillator + attack / decay envelope + 24db ladder filter. Basically the same as the [Synth](javascript:displayDocs('Gibberish.Synth'\\)) object but with the addition of the filter. Note that the envelope controls both the amplitude of the oscillator and the cutoff frequency of the filter.\n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.Synth2({ attack:44, decay:44100, cutoff:.2, resonance:4 }).connect();  \na.note(880);  \n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.Synth2.frequency : property  \nNumber. The frequency for the carrier oscillator. This is normally set using the note method but can also be modulated.\n**/\n/**###Gibberish.Synth2.pulsewidth : property  \nNumber. The duty cycle for PWM synthesis\n**/\n/**###Gibberish.Synth2.attack : property  \nNumber. The length of the attack portion of the envelope in samples. Note that the synth's envelope affects both amplitude and the index of the synth.\n**/\n/**###Gibberish.Synth2.decay : property  \nNumber. The length of the decay portion of the envelope in samples. Note that the synth's envelope affects both amplitude and the index of the synth.\n**/\n/**###Gibberish.Synth2.cutoff : property  \nNumber. 0..1. The cutoff frequency for the synth's filter.\n**/\n/**###Gibberish.Synth2.resonance : property  \nNumber. 0..50. Values above 4.5 are likely to produce shrieking feedback. You are warned.\n**/\n/**###Gibberish.Synth2.useLowPassFilter : property  \nBoolean. Default true. Whether to use a high-pass or low-pass filter.\n**/\n/**###Gibberish.Synth2.glide : property  \nNumber. The synth has a one-pole filter attached to the carrier frequency. Set glide to a value between .999 and 1 to get pitch sweep between notes.\n**/\n/**###Gibberish.Synth2.amp : property  \nNumber. The relative amplitude level of the synth.\n**/\n/**###Gibberish.Synth2.channels : property  \nNumber. Default 2. Mono or Stereo synthesis.\n**/\n/**###Gibberish.Synth2.pan : property  \nNumber. Default 0. If the synth has two channels, this determines its position in the stereo spectrum.\n**/\n/**###Gibberish.Synth2.waveform : property  \nString. The type of waveform to use. Options include 'Sine', 'Triangle', 'PWM', 'Saw' etc.\n**/\nGibberish.Synth2 = function(properties) {\n\tthis.name =\t\"synth2\";\n\n\tthis.properties = {\n\t  frequency:0,\n    pulsewidth:.5,\n\t  attack:\t\t22050,\n\t  decay:\t\t22050,\n    sustain:  22050,\n    release:  22050,\n    attackLevel: 1,\n    sustainLevel: .5,\n    releaseTrigger: 0,\n    cutoff:   .25,\n    resonance:3.5,\n    useLowPassFilter:true,\n    glide:    .15,\n    amp:\t\t  .25,\n    channels: 1,\n\t  pan:\t\t  0,\n    velocity: 1,\n    sr:       Gibberish.context.sampleRate,\n  };\n/**###Gibberish.Synth2.note : method  \nGenerate an enveloped note at the provided frequency  \n  \nparam **frequency** Number. The frequency for the oscillator.  \nparam **amp** Number. Optional. The volume to use.  \n**/      \n\tthis.note = function(frequency, velocity) {\n    if( typeof frequency === 'undefined' ) return\n    if( velocity !== 0 ) {\n  \t\tif(typeof this.frequency !== 'object'){\n        if( useADSR && frequency === lastFrequency && properties.requireReleaseTrigger ) {\n          this.releaseTrigger = 1;\n          lastFrequency = null\n          return;\n        }\n\n        this.frequency = lastFrequency = frequency;\n        this.releaseTrigger = 0;\n        if( typeof frequency === 'object' ) {\n          Gibberish.dirty( this )\n        }\n      }else{\n        this.frequency[0] = lastFrequency = frequency;\n        this.releaseTrigger = 0;\n        Gibberish.dirty(this);\n      }\n\t\t\t\t\t\n  \t\tif( typeof velocity !== 'undefined') this.velocity = velocity;\n\t  \n      _envelope.run();\n    }else{\n      this.releaseTrigger = 1;\n    }\n\t};\n  \n  properties = properties || {}\n  \n\tvar useADSR     = typeof properties.useADSR === 'undefined' ? false : properties.useADSR,\n      _envelope   = useADSR ? new Gibberish.ADSR() : new Gibberish.AD(),\n      envstate    = _envelope.getState,\n      envelope    = _envelope.callback,\n      _osc        = new Gibberish.PWM(),\n\t    osc         = _osc.callback,      \n      _filter     = new Gibberish.Filter24(),\n      filter      = _filter.callback,\n      lag         = new Gibberish.OnePole().callback,\n    \tpanner      = Gibberish.makePanner(),\n      lastFrequency = 0,\n      obj         = this,\n    \tout         = [0,0];\n      \n  _envelope.requireReleaseTrigger = properties.requireReleaseTrigger || false;\n        \n  this.callback = function(frequency, pulsewidth, attack, decay, sustain, release, attackLevel, sustainLevel, releaseTrigger, cutoff, resonance, isLowPass, glide, amp, channels, pan, velocity, sr) {\n    glide = glide >= 1 ? .99999 : glide;\n    frequency = lag(frequency, 1-glide, glide);\n    \n    var env, val\n    if( useADSR ) {\n      env = envelope( attack, decay, sustain, release, attackLevel, sustainLevel, releaseTrigger );\n      if( releaseTrigger ) {\n        obj.releaseTrigger = 0\n      }\n\n      if( envstate() < 4 ) {\n  \t\t\tval = filter ( osc( frequency, .15, pulsewidth, sr ), cutoff * env, resonance, isLowPass ) * env * velocity *  amp;\n    \n  \t\t\treturn channels === 1 ? val : panner(val, pan, out);\n      }else{\n  \t\t  val = out[0] = out[1] = 0;\n        return channels === 1 ? val : out\n      }\n    }else{\n      if( envstate() < 2) {\n\t\t\t  env = envelope(attack, decay);\n\t\t\t  val = filter ( osc( frequency, .15, pulsewidth, sr ), cutoff * env, resonance, isLowPass ) * env * velocity *  amp;\n      \n    \t\treturn channels === 1 ? val : panner(val, pan, out);\n      }else{\n    \t  val = out[0] = out[1] = 0;\n        return channels === 1 ? val : out;\n      }\n    }\n\t};\n  this.getUseADSR = function() { return useADSR; }\n  this.getEnv = function() { return _envelope; };\n  this.getOsc = function() { return _osc; };\n  this.setOsc = function(val) { _osc = val; osc = _osc.callback };\n  \n  var waveform = \"PWM\";\n  Object.defineProperty(this, 'waveform', {\n    get : function() { return waveform; },\n    set : function(val) { this.setOsc( new Gibberish[val]() ); }\n  });\n  \n  this.init();\n  this.oscillatorInit();\n\tthis.processProperties(arguments);\n};\nGibberish.Synth2.prototype = Gibberish._synth;\n\n/**#Gibberish.PolySynth2 - Synth\nA polyphonic version of [Synth2](javascript:displayDocs('Gibberish.Synth2'\\)). There are two additional properties for the polyphonic version of the synth. The polyphonic version consists of multiple Synths being fed into a single [Bus](javascript:displayDocs('Gibberish.Bus'\\)) object.\n  \n## Example Usage ##\n`Gibberish.init();  \na = new Gibberish.PolySynth2({ attack:88200, decay:88200, maxVoices:10 }).connect();  \na.note(880);  \na.note(1320); \na.note(1760);  \n`  \n## Constructor   \nOne important property to pass to the constructor is the maxVoices property, which defaults to 5. This controls how many voices are allocated to the synth and cannot be changed after initialization.  \n  \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.PolySynth2.children : property  \nArray. Read-only. An array holding all of the child FMSynth objects.\n**/\n/**###Gibberish.PolySynth2.maxVoices : property  \nNumber. The number of voices of polyphony the synth has. May only be set in initialization properties passed to constrcutor.\n**/\n\nGibberish.PolySynth2 = function() {\n  this.__proto__ = new Gibberish.Bus2();\n  \n  Gibberish.extend(this, {\n    name:     \"polysynth2\",\n    maxVoices:    5,\n    voiceCount:   0,\n    frequencies:  [],\n    _frequency: 0,\n    \n    polyProperties : {\n      frequency: 0,\n      glide:\t\t\t0,\n      attack: 22050,\n      decay:  22050,\n      sustain:22050,\n      release:22050,\n      attackLevel: 1,\n      sustainLevel: .5,      \n      pulsewidth:.5,\n      resonance: 3.5,\n      cutoff:.25,\n      velocity:1,\n      useLowPassFilter:true,\n      waveform:\"PWM\",\n    },\n\n/**###Gibberish.PolySynth2.note : method  \nGenerate an enveloped note at the provided frequency using a simple voice allocation system where if all children are active, the one active the longest cancels its current note and begins playing a new one.    \n  \nparam **frequency** Number. The frequency for the oscillator. \nparam **amp** Number. Optional. The volume to use.  \n**/  \n    note : function(_frequency, velocity) {\n      if( typeof _frequency === 'undefined' ) return\n\n      var lastNoteIndex = this.frequencies.indexOf( _frequency ),\n          idx = lastNoteIndex > -1 ? lastNoteIndex : this.voiceCount++,\n          synth = this.children[ idx ];\n      \n      synth.note(_frequency, velocity);\n            \n      if( lastNoteIndex === -1) {\n        this.frequencies[ idx ] = _frequency;\n        this._frequency = _frequency\n        if(this.voiceCount >= this.maxVoices) this.voiceCount = 0;\n      }else{\n        delete this.frequencies[ idx ]\n      }\n      this.lastChild = idx\n    },\n    \n    initVoices: function() {\n      this.dirty = true;\n      for(var i = 0; i < this.maxVoices; i++) {\n        var props = {\n    \t\t\tattack: \tthis.attack,\n    \t\t\tdecay:\t\tthis.decay,\n          sustain:  this.sustain,\n          release:  this.release,\n          attackLevel: this.attackLevel,\n          sustainLevel: this.sustainLevel,\n          pulsewidth: this.pulsewidth,\n          channels: 2,\n          amp:      1,\n          useADSR:  this.useADSR || false,\n          requireReleaseTrigger: this.requireReleaseTrigger || false,\n        },\n        synth = new Gibberish.Synth2( props ).connect( this );\n\n        this.children.push(synth);\n      }\n    },\n  });\n  \n  this.amp = 1 / this.maxVoices;\n    \n  this.children = [];\n  \n  if(typeof arguments[0] === 'object') {\n    this.maxVoices = arguments[0].maxVoices ? arguments[0].maxVoices : this.maxVoices\n    this.useADSR = typeof arguments[0].useADSR !== 'undefined' ? arguments[ 0 ].useADSR : false\n    this.requireReleaseTrigger = typeof arguments[0].requireReleaseTrigger !== 'undefined' ? arguments[ 0 ].requireReleaseTrigger : false\n  }\n  \n  Gibberish.polyInit(this);\n  \n  this.initVoices()\n\n  this.processProperties(arguments);\n  Gibberish._synth.oscillatorInit.call(this);\n};\n\n/**#Gibberish.FMSynth - Synth\nClassic 2-op FM synthesis with an attached attack / decay envelope.\n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.FMSynth({ cmRatio:5, index:3 }).connect();\na.note(880);`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.FMSynth.frequency : property  \nNumber. The frequency for the carrier oscillator. This is normally set using the note method but can also be modulated.\n**/\n/**###Gibberish.FMSynth.cmRatio : property  \nNumber. The carrier-to-modulation ratio. A cmRatio of 2 means that the carrier frequency will be twice the frequency of the modulator.\n**/\n/**###Gibberish.FMSynth.attack : property  \nNumber. The length of the attack portion of the envelope in samples. Note that the synth's envelope affects both amplitude and the index of the synth.\n**/\n/**###Gibberish.FMSynth.decay : property  \nNumber. The length of the decay portion of the envelope in samples. Note that the synth's envelope affects both amplitude and the index of the synth.\n**/\n/**###Gibberish.FMSynth.glide : property  \nNumber. The synth has a one-pole filter attached to the carrier frequency. Set glide to a value between .999 and 1 to get pitch sweep between notes.\n**/\n/**###Gibberish.FMSynth.amp : property  \nNumber. The relative amplitude level of the synth.\n**/\n/**###Gibberish.FMSynth.channels : property  \nNumber. Default 2. Mono or Stereo synthesis.\n**/\n/**###Gibberish.FMSynth.pan : property  \nNumber. Default 0. If the synth has two channels, this determines its position in the stereo spectrum.\n**/\nGibberish.FMSynth = function(properties) {\n\tthis.name =\t\"fmSynth\";\n\n  this.properties = {\n\t  frequency:0,\n\t  cmRatio:\t2,\n\t  index:\t\t5,\t\t\t\n\t  attack:\t\t22050,\n\t  decay:\t\t22050,\n    sustain:  22050,\n    release:  22050,\n    attackLevel: 1,\n    sustainLevel: .5,\n    releaseTrigger: 0,\n    glide:    .15,\n    amp:\t\t  .25,\n    channels: 2,\n    velocity: 1,\n\t  pan:\t\t  0,\n  };\n/**###Gibberish.FMSynth.note : method  \nGenerate an enveloped note at the provided frequency  \n  \nparam **frequency** Number. The frequency for the carrier oscillator. The modulator frequency will be calculated automatically from this value in conjunction with the synth's carrier to modulation ratio  \nparam **amp** Number. Optional. The volume to use.  \n**/\n\n\tthis.note = function(frequency, velocity) {\n    if( typeof frequency === 'undefined' ) return\n    //console.log( frequency, lastFrequency, this.releaseTrigger, velocity )\n    if( velocity !== 0 ) {\n  \t\tif(typeof this.frequency !== 'object'){\n        if( useADSR && frequency === lastFrequency && properties.requireReleaseTrigger ) {\n          this.releaseTrigger = 1;\n          lastFrequency = null\n          return;\n        }\n        \n        this.frequency = lastFrequency = frequency;\n        this.releaseTrigger = 0;\n        \n        if( typeof frequency === 'object' ) {\n          Gibberish.dirty( this );\n        }\n      }else{\n        this.frequency[0] = lastFrequency = frequency;\n        this.releaseTrigger = 0;\n        Gibberish.dirty(this);\n      }\n\t\t\t\t\t\n  \t\tif( typeof velocity !== 'undefined') this.velocity = velocity;\n\t  \n      _envelope.run();\n    }else{\n      this.releaseTrigger = 1;\n    }\n\t};\n  \n  properties = properties || {}\n  \n\tvar useADSR     = typeof properties.useADSR === 'undefined' ? false : properties.useADSR,\n      _envelope   = useADSR ? new Gibberish.ADSR() : new Gibberish.AD(),\n      envstate    = _envelope.getState,\n      envelope    = _envelope.callback,\n\t    carrier     = new Gibberish.Sine().callback,\n\t    modulator   = new Gibberish.Sine().callback,\n      lag         = new Gibberish.OnePole().callback,\n    \tpanner      = Gibberish.makePanner(),\n    \tout         = [0,0],\n      obj         = this,\n      lastFrequency = 0,\n      phase = 0,\n      check = false;\n\n  _envelope.requireReleaseTrigger = properties.requireReleaseTrigger || false;\n\n  this.callback = function(frequency, cmRatio, index, attack, decay, sustain, release, attackLevel, sustainLevel, releaseTrigger, glide, amp, channels, velocity, pan) {\n    var env, val, mod\n        \n    if(glide >= 1) glide = .9999;\n    frequency = lag(frequency, 1-glide, glide);\n    \n    if( useADSR ) {\n      env = envelope( attack, decay, sustain, release, attackLevel, sustainLevel, releaseTrigger ) * velocity;\n      if( releaseTrigger ) {\n        obj.releaseTrigger = 0\n      }\n\n      if( envstate() < 4 ) {\n        mod = modulator(frequency * cmRatio, frequency * index) * env;\n  \t\t\tval = carrier( frequency + mod, 1 ) * env * amp;\n\n  \t\t\treturn channels === 1 ? val : panner(val, pan, out);\n      }else{\n  \t\t  val = out[0] = out[1] = 0;\n        return channels === 1 ? val : out\n      }\n    }else{\n      if( envstate() < 2 ) {\n  \t\t\tenv = envelope(attack, decay) * velocity;\n  \t\t\tmod = modulator(frequency * cmRatio, frequency * index) * env;\n  \t\t\tval = carrier( frequency + mod, 1 ) * env * amp;\n\n        //if( phase++ % 44105 === 0 ) console.log( panner(val, pan, out) , channels )\n  \t\t\treturn channels === 1 ? val : panner(val, pan, out);\n      }else{\n  \t\t  val = out[0] = out[1] = 0;\n        return channels === 1 ? val : out;\n      }\n    }\n\t};\n  \n  this.init();\n  this.oscillatorInit();\n\tthis.processProperties(arguments);\n};\nGibberish.FMSynth.prototype = Gibberish._synth;\n/**#Gibberish.PolyFM - Synth\nA polyphonic version of [FMSynth](javascript:displayDocs('Gibberish.FMSynth'\\)). There are two additional properties for the polyphonic version of the synth. The polyphonic version consists of multiple FMSynths being fed into a single [Bus](javascript:displayDocs('Gibberish.Bus'\\)) object.\n  \n## Example Usage ##\n`Gibberish.init();  \na = new Gibberish.PolyFM({ cmRatio:5, index:3, attack:88200, decay:88200 }).connect();  \na.note(880);  \na.note(1320);  \n`  \n## Constructor   \nOne important property to pass to the constructor is the maxVoices property, which defaults to 5. This controls how many voices are allocated to the synth and cannot be changed after initialization.  \n  \n**param** *properties*: Object. A dictionary of property values (see below) to set for the synth on initialization.\n- - - -\n**/\n/**###Gibberish.PolyFM.children : property  \nArray. Read-only. An array holding all of the child FMSynth objects.\n**/\n/**###Gibberish.PolyFM.maxVoices : property  \nNumber. The number of voices of polyphony the synth has. May only be set in initialization properties passed to constrcutor.\n**/\n\n\nGibberish.PolyFM = function() {\n  this.__proto__ = new Gibberish.Bus2();\n  \n\tGibberish.extend(this, {\n    name:     \"polyfm\",\n\t\tmaxVoices:\t\t5,\n\t\tvoiceCount:\t\t0,\n    children: [],\n    frequencies: [],\n    _frequency: 0,\n    velocity: 1,\n\n    polyProperties : {\n      glide:\t\t 0,\n      attack: 22050,\n      decay:  22050,\n      sustain:22050,\n      release:22050,\n      attackLevel: 1,\n      sustainLevel: .5,\n      index:  5,\n      cmRatio:2,\n    },\n/**###Gibberish.PolyFM.note : method  \nGenerate an enveloped note at the provided frequency using a simple voice allocation system where if all children are active, the one active the longest cancels its current note and begins playing a new one.    \n  \nparam **frequency** Number. The frequency for the carrier oscillator. The modulator frequency will be calculated automatically from this value in conjunction with the synth's  \nparam **amp** Number. Optional. The volume to use.  \n**/\n    note : function(_frequency, velocity ) {\n      if( typeof _frequency === 'undefined' ) return\n\n      var lastNoteIndex = this.frequencies.indexOf( _frequency ),\n          idx = lastNoteIndex > -1 ? lastNoteIndex : this.voiceCount++,\n          synth = this.children[ idx ];\n      \n      if( typeof velocity === 'undefined' ) velocity = this.velocity\n\n      synth.note(_frequency, velocity);\n      \n      if( lastNoteIndex === -1) {\n        this.frequencies[ idx ] = _frequency;\n        this._frequency = _frequency\n        if(this.voiceCount >= this.maxVoices) this.voiceCount = 0;\n      }else{\n        delete this.frequencies[ idx ]\n      }\n    },\n    \n    initVoices : function() {\n    \tfor(var i = 0; i < this.maxVoices; i++) {\n    \t\tvar props = {\n    \t\t\tattack: \tthis.attack,\n    \t\t\tdecay:\t\tthis.decay,\n          sustain:  this.sustain,\n          release:  this.release,\n          attackLevel: this.attackLevel,\n          sustainLevel: this.sustainLevel,\n    \t\t\tcmRatio:\tthis.cmRatio,\n    \t\t\tindex:\t\tthis.index,\n          channels: 2,\n          useADSR : this.useADSR || false,      \n          requireReleaseTrigger: this.requireReleaseTrigger || false,\n    \t\t\tamp: \t\t  1,\n    \t\t};\n\n    \t\tvar synth = new Gibberish.FMSynth(props);\n    \t\tsynth.connect(this);\n\n    \t\tthis.children.push(synth);\n    \t}\n    },\n\t}); \n     \n  this.amp = 1 / this.maxVoices;\n    \n  this.children = [];\n  \n  if(typeof arguments[0] === 'object') {\n    this.maxVoices = arguments[0].maxVoices ? arguments[0].maxVoices : this.maxVoices\n    this.useADSR = typeof arguments[0].useADSR !== 'undefined' ? arguments[ 0 ].useADSR : false    \n    this.requireReleaseTrigger = typeof arguments[0].requireReleaseTrigger !== 'undefined' ? arguments[ 0 ].requireReleaseTrigger : false    \n  }\n  \n  Gibberish.polyInit(this);\n  this.initVoices()\n  \n\tthis.processProperties(arguments);\n  Gibberish._synth.oscillatorInit.call(this);\n};\n\n// this file is dependent on oscillators.js\n\n/**#Gibberish.Sampler - Oscillator\nSample recording and playback.\n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.Sampler({ file:'resources/snare.wav' }).connect();  \n// wait until sample has downloaded  \na.note(2);  \na.note(1);  \na.note(-.5);  \nb = new Gibberish.Sampler().connect();  \nb.record(a, 88200); // record two seconds of a playing  \na.note(8);  \n// wait a bit    \nb.note(1);`\n\n## Constructor\n###syntax 1  \n**param** *filepath*: String. A path to the audiofile to be opened by the sampler.  \n###syntax 2    \n**param** *properties*: Object. A dictionary of property values (see below) to set for the sampler on initialization.\n- - - -\n**/\n/**###Gibberish.Sampler.pitch : property  \nNumber. The speed that the sample is played back at. A pitch of 1 means the sample plays forward at speed it was recorded at, a pitch of -4 means the sample plays backwards at 4 times the speed it was recorded at.\n**/\n/**###Gibberish.Sampler.amp : property  \nNumber. A linear value specifying relative amplitude, ostensibly from 0..1 but can be higher, or lower when used for modulation.\n**/\n/**###Gibberish.Sampler.playOnLoad : property  \nNumber. If this value is set to be non-zero, the sampler will trigger a note at the provided pitch as soon as the sample is downloaded. \n**/\n/**###Gibberish.Sampler.isRecording : property  \nBoolean. Tells the sample to record into it's buffer. This is handled automatically by the object; there is no need to manually set this property.\n**/\n/**###Gibberish.Sampler.isPlaying : property  \nNumber. 0..1. Tells the sample to record into it's buffer. This is handled automatically by the object; there is no need to manually set this property.\n**/\n/**###Gibberish.Sampler.input : property  \nObject. The object the sampler is tapping into and recording.\n**/\n/**###Gibberish.Sampler.length : property  \nNumber. The length of the Sampler's buffer.\n**/\n/**###Gibberish.Sampler.start : property  \nNumber. When the Sampler's note method is called, sample playback begins at this sample.\n**/\n/**###Gibberish.Sampler.end : property  \nNumber. When the Sampler's note method is called, sample playback ends at this sample.\n**/\n/**###Gibberish.Sampler.loops : property  \nBoolean. When true, sample playback loops continuously between the start and end property values.\n**/\n/**###Gibberish.Sampler.pan : property  \nNumber. -1..1. Position of the Sampler in the stereo spectrum.\n**/\n\nGibberish.Sampler = function() {\n\tvar phase = 1,\n\t    interpolate = Gibberish.interpolate,\n\t    write = 0,\n\t    panner = Gibberish.makePanner(),\n\t    debug = 0 ,\n\t    shouldLoop = 0,\n\t    out = [0,0],\n      buffer = null,\n      bufferLength = 1,\n      self = this,\n      count = 0;\n      \n\tGibberish.extend(this, {\n\t\tname: \t\t\t\"sampler\",\n    \n\t\tfile: \t\t\tnull,\n\t\tisLoaded: \tfalse,\n    playOnLoad :  0,\n    buffers: {},\n    properties : {\n    \tpitch:\t\t\t  1,\n  \t\tamp:\t\t\t    1,\n  \t\tisRecording: \tfalse,\n  \t\tisPlaying : \ttrue,\n  \t\tinput:\t \t\t  0,\n  \t\tlength : \t\t  0,\n      start :       0,\n      end :         1,\n      loops :       0,\n      pan :         0,\n    },\n    \n/**###Gibberish.Sampler.onload : method  \nThis is an event handler that is called when a sampler has finished loading an audio file.\nUse this to trigger a set of events upon downloading the sample. \n  \nparam **buffer** Object. The decoded sampler buffers from the audio file\n**/ \n\t\t_onload : \t\tfunction(decoded) {\n\t\t\tbuffer = decoded.channels[0]; \n\t\t\tbufferLength = decoded.length;\n\t\t\tself.length = bufferLength\n\t\t\t//self.end = bufferLength;\n      self.length = phase = bufferLength;\n      self.isPlaying = true;\n\t\t\t\t\t\n\t\t\t//console.log(\"LOADED \", self.file, bufferLength);\n\t\t\tGibberish.audioFiles[self.file] = buffer;\n\t\t\tself.buffers[ self.file ] = buffer;\n      \n      if(self.onload) self.onload();\n      \n      if(self.playOnLoad !== 0) self.note(self.playOnLoad);\n      \n\t\t\tself.isLoaded = true;\n\t\t},\n    \n    switchBuffer: function( bufferID ) { // accepts either number or string\n      if( typeof bufferID === 'string' ) {\n        if( typeof this.buffers[ bufferID ] !== 'undefined' ) {\n          buffer = this.buffers[ bufferID ]\n          //bufferLength = this.end = this.length = buffer.length\n          bufferLength = this.length = buffer.length\n        }\n      }else if( typeof bufferID === 'number' ){\n        var keys = Object.keys( this.buffers )\n        if( keys.length === 0 ) return \n        //console.log( \"KEY\", keys, keys[ bufferID ], bufferID )\n        buffer = this.buffers[ keys[ bufferID ] ]\n        bufferLength  = this.length = buffer.length\n        //this.end( bufferLength )\n        this.setPhase( 0 )\n        //console.log( bufferLength, this.end, this.length )\n      }\n    },\n    \n    floatTo16BitPCM : function(output, offset, input){\n      //console.log(output.length, offset, input.length )\n      for (var i = 0; i < input.length - 1; i++, offset+=2){\n        var s = Math.max(-1, Math.min(1, input[i]));\n        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n      }\n    },\n    encodeWAV : function(){\n      //console.log(\"BUFFER LENGTH\" + _buffer.length);\n      var _buffer = this.getBuffer(),\n          wavBuffer = new ArrayBuffer(44 + _buffer.length * 2),\n          view = new DataView(wavBuffer),\n          sampleRate = Gibberish.context.sampleRate;\n      \n      function writeString(view, offset, string){\n        for (var i = 0; i < string.length; i++){\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      /* RIFF identifier */\n      writeString(view, 0, 'RIFF');\n      /* file length */\n      view.setUint32(4, 32 + _buffer.length * 2, true);\n      /* RIFF type */\n      writeString(view, 8, 'WAVE');\n      /* format chunk identifier */\n      writeString(view, 12, 'fmt ');\n      /* format chunk length */\n      view.setUint32(16, 16, true);\n      /* sample format (raw) */\n      view.setUint16(20, 1, true);\n      /* channel count */\n      view.setUint16(22, 1, true);\n      /* sample rate */\n      view.setUint32(24, sampleRate, true);\n      /* byte rate (sample rate * block align) */\n      view.setUint32(28, sampleRate * 4, true);\n      /* block align (channel count * bytes per sample) */\n      view.setUint16(32, 2, true);\n      /* bits per sample */\n      view.setUint16(34, 16, true);\n      /* data chunk identifier */\n      writeString(view, 36, 'data');\n      /* data chunk length */\n      view.setUint32(40, _buffer.length * 2, true);\n\n      this.floatTo16BitPCM(view, 44, _buffer);\n\n      return view;\n    },\n/**###Gibberish.Sampler.download : method  \nDownload the sampler buffer as a .wav file. In conjunction with the record method, this enables the Sampler\nto record and downlaod Gibberish sessions.\n**/  \n    download : function() {\n      var blob = this.encodeWAV();\n      var audioBlob = new Blob( [ blob ] );\n\n      var url =  window.webkitURL.createObjectURL( audioBlob );\n      var link = window.document.createElement('a');\n      link.href = url;\n      link.download = 'output.wav';\n      \n      var click = document.createEvent(\"Event\");\n      click.initEvent(\"click\", true, true);\n      \n      link.dispatchEvent(click);\n    },\n\n/**###Gibberish.Sampler.note : method  \nTrigger playback of the samplers buffer\n  \nparam **pitch** Number. The speed the sample is played back at.  \nparam **amp** Number. Optional. The volume to use.\n**/   \n\n/**###Gibberish.Sampler.range : method  \nSet the start and end points in a single method call\n  \nparam **start** Number. The start point for sample playback, 0..1\nparam **end** Number. The end point for sample playback, 0..1\n**/  \n    range: function( start, end ) {\n      if( Array.isArray( start ) ) {\n        end = start[1]\n        start = start[0] \n      }\n      \n      if( end < start ) {\n        var tmp = start\n        start = end\n        end = tmp\n      }\n      \n      this.start = start\n      this.end = end\n    },\n\n\t\tnote: function(pitch, amp) {\n      if( typeof pitch === 'undefined' ) return\n\n      switch( typeof pitch ) {\n        case 'number' :\n          this.pitch = pitch\n          break;\n        case 'function' :\n          this.pitch = pitch()\n          break;\n        case 'object' :\n          if( Array.isArray(pitch) ) {\n            this.pitch = pitch[ 0 ]\n          }else{\n            this.pitch = pitch\n          }\n          break;\n      }\n      // if(typeof this.pitch === 'number' || typeof this.pitch === 'function' ){\n      //   this.pitch = pitch;\n      // }else if(typeof this.pitch === 'object'){\n      //   this.pitch[0] = pitch;\n      //   Gibberish.dirty(this);\n      // }\n      \n\t\t\tif(typeof amp === 'number') this.amp = amp;\n\t\t\t\n\t\t\tif(this.function !== null) {\n\t\t\t\tthis.isPlaying = true;\t// needed to allow playback after recording\n        \n        var __pitch;// = typeof this.pitch === 'number' || typeof this.pitch === 'function' ? this.pitch : this.pitch[0];  // account for modulations\n                \n        switch( typeof this.pitch ) {\n          case 'number' :\n            __pitch = this.pitch\n            break;\n          case 'function' :\n            __pitch = this.pitch.getValue ? this.pitch.getValue() : this.pitch()\n            break;\n          case 'object' :\n            if( Array.isArray( this.pitch ) ) {\n              __pitch = this.pitch[ 0 ]\n            } else {\n              __pitch = this.pitch.getValue ? this.pitch.getValue() : this.pitch.input.getValue()              \n            }\n            \n            if( typeof __pitch === 'function' ) __pitch = __pitch()\n            \n            break;\n        }\n        \n        //         if( __pitch > 0 ) { //|| typeof __pitch === 'object' || typeof this.pitch === 'function' ) {\n        //           phase = this.start;\n        // }else{\n        //           phase = this.end;\n        // }\n        phase = 0\n        \n        Gibberish.dirty( this )\n        \n        //this.pitch = __pitch;\n\t\t\t}\n\t\t},\n/**###Gibberish.Sampler.record : method  \nRecord the output of a Gibberish ugen for a given amount of time\n  \nparam **ugen** Object. The Gibberish ugen to be recorded.\nparam **recordLength** Number (in samples). How long to record for.\n**/     \n    // record : function(input, recordLength) {\n    //       this.isRecording = true;\n    //       \n    //       var self = this;\n    //       \n    //       this.recorder = new Gibberish.Record(input, recordLength, function() {\n    //         self.setBuffer( this.getBuffer() );\n    //         self.end = bufferLength = self.getBuffer().length;\n    //         self.setPhase( self.end )\n    //         self.isRecording = false;\n    //       })\n    //       .record();\n    //       \n    //       return this;\n    // },\n\n/**###Gibberish.Sampler.getBuffer : method  \nReturns a pointer to the Sampler's internal buffer.  \n**/\n    getBuffer : function() { return buffer; },\n    setBuffer : function(b) { buffer = b },\n    getPhase : function() { return phase },\n    setPhase : function(p) { phase = p },\n    getNumberOfBuffers: function() { return Object.keys( self.buffers ).length - 1 },\n    \n/**###Gibberish.Sampler.callback : method  \nReturn a single sample. It's a pretty lengthy method signature, they are all properties that have already been listed:  \n\n_pitch, amp, isRecording, isPlaying, input, length, start, end, loops, pan\n**/    \n  \tcallback :function(_pitch, amp, isRecording, isPlaying, input, length, start, end, loops, pan) {\n  \t\tvar val = 0, startInSamples = start * length, endInSamples = end * length;\n  \t\tphase += _pitch;\n      \n      // if( count++ % 44100 === 0 ) console.log( _pitch, startInSamples, endInSamples )\n      \n      if( buffer !== null && isPlaying ) {\n        if( _pitch > 0 ) {\n          if( startInSamples + phase < endInSamples ) {\n            val = interpolate( buffer, startInSamples + phase )\n          }else{\n            if( loops ) phase = 0\n          }\n        }else{\n          if( endInSamples + phase > startInSamples ) {\n            val = interpolate( buffer, endInSamples + phase )\n          }else{\n            if( loops ) phase = 0\n          }\n        }\n        \n        return panner( val * amp, pan, out )\n      }\n\t\n  \t\tout[0] = out[1] = val;\n  \t\treturn out;\n  \t},\n\t})\n  .init()\n  .oscillatorInit()\n  .processProperties(arguments);\n  \n\tif(typeof arguments[0] !== \"undefined\") {\n\t\tif(typeof arguments[0] === \"string\") {\n\t\t\tthis.file = arguments[0];\n      this.pitch = 0;\n\t\t\t//this.isPlaying = true;\n\t\t}else if(typeof arguments[0] === \"object\") {\n\t\t\tif(arguments[0].file) {\n\t\t\t\tthis.file = arguments[0].file;\n\t\t\t\t//this.isPlaying = true;\n\t\t\t}\n\t\t}\n\t}\n  \n  //console.log(this);\n  \t\t\n\t/*var _end = 1;\n\tObject.defineProperty(that, \"end\", {\n\t\tget : function() { return _end; },\n\t\tset : function(val) {\n\t\t\tif(val > 1) val = 1;\n\t\t\t_end = val * that.bufferLength - 1;\n\t\t\tGibberish.dirty(that);\n\t\t}\n\t});\n\tvar _start = 0;\n\tObject.defineProperty(that, \"start\", {\n\t\tget : function() { return _start; },\n\t\tset : function(val) {\n\t\t\tif(val < 0) val = 0;\n\t\t\t_start = val * that.bufferLength - 1;\n\t\t\tGibberish.dirty(that);\n\t\t}\n\t});\n\tvar _loops = 0;\n\tObject.defineProperty(that, \"loops\", {\n\t\tget : function() { return _loops; },\n\t\tset : function(val) {\n\t\t\t_loops = val;\n\t\t\tthat.function.setLoops(_loops);\n\t\t}\n\t});\n  */\n  \n\tif(typeof Gibberish.audioFiles[this.file] !== \"undefined\") {\n\t\tbuffer =  Gibberish.audioFiles[this.file];\n\t\tthis.end = 1;\n\t\tthis.buffers[ this.file ] = buffer;\n    \n    this.length = phase = this.bufferLength = buffer.length;\n    Gibberish.dirty(this);\n    \n    if(this.onload) this.onload();\n\t}else if(this.file !== null){\n    var xhr = new XMLHttpRequest(), initSound\n        \n    xhr.open( 'GET', this.file, true )\n    xhr.responseType = 'arraybuffer'\n    xhr.onload = function( e ) { initSound( this.response ) }\n    xhr.send()\n    \n    //console.log(\"now loading sample\", self.file )\n    xhr.onerror = function( e ) { console.error( \"Sampler file loading error\", e )}\n    \n    initSound = function( arrayBuffer ) {\n      Gibberish.context.decodeAudioData(arrayBuffer, function(_buffer) {\n        buffer = _buffer.getChannelData(0)\n        // self.length = phase = self.end = bufferLength = buffer.length\n        self.length = phase = bufferLength = buffer.length\n        self.isPlaying = true;\n  \t\t\tself.buffers[ self.file ] = buffer;\n\n        //console.log(\"sample loaded | \", self.file, \" | length | \", bufferLength);\n  \t\t\tGibberish.audioFiles[self.file] = buffer;\n\t\t\t\n        if(self.onload) self.onload();\n      \n        if(self.playOnLoad !== 0) self.note( self.playOnLoad );\n      \n  \t\t\tself.isLoaded = true;\n      }, function(e) {\n        console.log('Error decoding file', e);\n      }); \n    }\n\t}else if(typeof this.buffer !== 'undefined' ) {\n\t\tthis.isLoaded = true;\n\t\t\t\t\t\n\t\tbuffer = this.buffer;\n    //this.end = this.bufferLength = buffer.length || 88200;\n    this.bufferLength = buffer.length || 88200;\n\t\t    \n\t\tphase = this.bufferLength;\n\t\tif(arguments[0] && arguments[0].loops) {\n\t\t\tthis.loops = 1;\n\t\t}\n    Gibberish.dirty(this);\n    \n    if(this.onload) this.onload();\n\t}\n};\nGibberish.Sampler.prototype = Gibberish._oscillator;\nGibberish.Sampler.prototype.record = function(input, recordLength) {\n  this.isRecording = true;\n  \n  var self = this;\n  \n  this.recorder = new Gibberish.Record(input, recordLength, function() {\n    self.setBuffer( this.getBuffer() );\n    bufferLength = self.getBuffer().length;\n    self.setPhase( self.end )\n    self.isRecording = false;\n  })\n  .record();\n  \n  return this;\n};\n\n/**#Gibberish.MonoSynth - Synth\nA three oscillator monosynth for bass and lead lines. You can set the octave and tuning offsets for oscillators 2 & 3. There is a 24db filter and an envelope controlling\nboth the amplitude and filter cutoff.\n## Example Usage##\n`  \nt = new Gibberish.Mono({  \n\tcutoff:0,  \n\tfilterMult:.5,  \n\tattack:_8,  \n\tdecay:_8,  \n\toctave2:-1,  \n\toctave3:-1,  \n\tdetune2:.01,  \n\tglide:_12,  \n}).connect();  \nt.note(\"C3\");  `\n## Constructors\n  param **arguments** : Object. A dictionary of property values to set upon initialization. See the properties section and the example usage section for details.\n**/\n/**###Gibberish.MonoSynth.waveform : property\nString. The primary oscillator to be used. Can currently be 'Sine', 'Square', 'Noise', 'Triangle' or 'Saw'. \n**/\n/**###Gibberish.MonoSynth.attack : property\nInteger. The length, in samples, of the attack of the amplitude envelope.\n**/\n/**###Gibberish.MonoSynth.decay : property\nInteger. The length, in samples, of the decay of the amplitude envelope.\n**/\n/**###Gibberish.MonoSynth.amp : property\nFloat. The peak amplitude of the synth, usually between 0..1\n**/\n/**###Gibberish.MonoSynth.cutoff : property\nFloat. The frequency cutoff for the synth's filter. Range is 0..1.\n**/\n/**###Gibberish.MonoSynth.filterMult : property\nFloat. As the envelope on the synth progress, the filter cutoff will also change by this amount * the envelope amount.\n**/\n/**###Gibberish.MonoSynth.resonance : property\nFloat. The emphasis placed on the filters cutoff frequency. 0..50, however, GOING OVER 5 IS DANGEROUS TO YOUR EARS (ok, maybe 6 is all right...)\n**/\n/**###Gibberish.MonoSynth.octave2 : property\nInteger. The octave difference between oscillator 1 and oscillator 2. Can be positive (higher osc2) or negative (lower osc 2) or 0 (same octave).\n**/\n/**###Gibberish.MonoSynth.detune2 : property\nFloat. The amount, from -1..1, the oscillator 2 is detuned. A value of -.5 means osc2 is half an octave lower than osc1. A value of .01 means osc2 is .01 octaves higher than osc1.\n**/\n/**###Gibberish.MonoSynth.octave3 : property\nInteger. The octave difference between oscillator 1 and oscillator 3. Can be positive (higher osc3) or negative (lower osc 3) or 0 (same octave).\n**/\n/**###Gibberish.MonoSynth.detune3 : property\nFloat. The amount, from -1..1, the oscillator 3 is detuned. A value of -.5 means osc3 is half an octave lower than osc1. A value of .01 means osc3 is .01 octaves higher than osc1.\n**/\n/**###Gibberish.MonoSynth.glide : property\nInteger. The length in time, in samples, to slide in pitch from one note to the next.\n**/\nGibberish.MonoSynth = function() {  \n\tGibberish.extend(this, { \n    name:       'monosynth',\n    \n    properties: {\n  \t\tattack:\t\t\t10000,\n  \t\tdecay:\t\t\t10000,\n  \t\tcutoff:\t\t\t.2,\n  \t\tresonance:\t2.5,\n  \t\tamp1:\t\t\t  1,\n  \t\tamp2:\t\t\t  1,\n  \t\tamp3:\t\t\t  1,\n  \t\tfilterMult:\t.3,\n  \t\tisLowPass:\ttrue,\n      pulsewidth: .5,\n  \t\tamp:\t\t    .6,\n  \t\tdetune2:\t\t.01,\n  \t\tdetune3:\t\t-.01,\n  \t\toctave2:\t\t1,\n  \t\toctave3:\t\t-1,\n      glide:      0,\n  \t\tpan:\t\t\t  0,\n      velocity:   1,\n  \t\tfrequency:\t0,\n      channels:   2,\n    },\n    \n\t\twaveform:\t\t\"Saw3\",\n/**###Gibberish.MonoSynth.note : method\nparam **note or frequency** : String or Integer. You can pass a note name, such as \"A#4\", or a frequency value, such as 440.\nparam **amp** : Optional. Float. The volume of the note, usually between 0..1. The main amp property of the Synth will also affect note amplitude.\n**/\t\t\t\t\n\t\tnote : function(_frequency, velocity) {\n      if( typeof _frequency === 'undefined' ) return\n\n      if(typeof velocity !== 'undefined' && velocity !== 0) this.velocity = velocity;\n      \n      if( velocity !== 0 ) {\n    \t\tif(typeof this.frequency !== 'object'){\n      \n          this.frequency = _frequency;\n        }else{\n          this.frequency[0] = _frequency;\n          Gibberish.dirty(this);\n        }\n        \n  \t\t\tif(envstate() > 0 ) _envelope.run();\n      }\n\t\t},\n  \t/*\n    note : function(frequency, velocity) {\n      if( typeof frequency === 'undefined' ) return\n        \n  \t\tif(typeof this.frequency !== 'object'){\n        if( useADSR && frequency === lastFrequency && velocity === 0) {\n          this.releaseTrigger = 1;\n          lastFrequency = null\n          return;\n        }\n        if( velocity !== 0 ) {\n          this.frequency = lastFrequency = frequency;\n        }\n        this.releaseTrigger = 0;\n      }else{\n        if( velocity !== 0 ) {\n          this.frequency[0] = lastFrequency = frequency;\n        }\n        this.releaseTrigger = 0;\n        Gibberish.dirty(this);\n      }\n\t\t\t\t\t\n  \t\tif(typeof velocity !== 'undefined' && velocity !== 0) this.velocity = velocity;\n\t  \n      if( velocity !== 0 ) { _envelope.run(); }\n  \t},\n    */\n\t});\n  \n\tvar waveform = waveform1 = waveform2 = waveform3 = this.waveform;\n\tObject.defineProperty(this, \"waveform\", {\n\t\tget: function() { return waveform; },\n\t\tset: function(value) {\n\t\t\tif(waveform !== value) {\n\t\t\t\twaveform = value;\n\t\t\t\t\t\t\n\t\t\t\tosc1 = new Gibberish[ value ]().callback;\n\t\t\t\tosc2 = new Gibberish[ value ]().callback;\n\t\t\t\tosc3 = new Gibberish[ value ]().callback;\n\t\t\t}\n\t\t},\n\t});\n  \n  Object.defineProperties( this, {\n    waveform1: {\n      get: function() { return waveform1 },\n      set: function(v) { waveform1 = v; osc1 = new Gibberish[ v ]().callback; }\n    },\n    waveform2: {\n      get: function() { return waveform2 },\n      set: function(v) { waveform2 = v; osc2 = new Gibberish[ v ]().callback; }\n    },\n    waveform3: {\n      get: function() { return waveform3 },\n      set: function(v) { waveform3 = v; osc3 = new Gibberish[ v ]().callback; }\n    },\n  })\n  \n  \n\tvar _envelope = new Gibberish.AD(this.attack, this.decay),\n      envstate  = _envelope.getState,\n      envelope  = _envelope.callback,\n      filter    = new Gibberish.Filter24().callback,\n    \tosc1      = new Gibberish[this.waveform](this.frequency,  this.amp1).callback,\n    \tosc2      = new Gibberish[this.waveform](this.frequency2, this.amp2).callback,\n    \tosc3      = new Gibberish[this.waveform](this.frequency3, this.amp3).callback,\n      lag       = new Gibberish.OnePole().callback,      \n    \tpanner    = Gibberish.makePanner(),\n    \tout       = [0,0];\n  \n  this.envelope = _envelope\n  \n  this.callback = function(attack, decay, cutoff, resonance, amp1, amp2, amp3, filterMult, isLowPass, pulsewidth, masterAmp, detune2, detune3, octave2, octave3, glide, pan, velocity, frequency, channels) {\n\t\tif(envstate() < 2) {\n      if(glide >= 1) glide = .9999;\n      frequency = lag(frequency, 1-glide, glide);\n      \n\t\t\tvar frequency2 = frequency;\n\t\t\tif(octave2 > 0) {\n\t\t\t\tfor(var i = 0; i < octave2; i++) {\n\t\t\t\t\tfrequency2 *= 2;\n\t\t\t\t}\n\t\t\t}else if(octave2 < 0) {\n\t\t\t\tfor(var i = 0; i > octave2; i--) {\n\t\t\t\t\tfrequency2 /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t\tvar frequency3 = frequency;\n\t\t\tif(octave3 > 0) {\n\t\t\t\tfor(var i = 0; i < octave3; i++) {\n\t\t\t\t\tfrequency3 *= 2;\n\t\t\t\t}\n\t\t\t}else if(octave3 < 0) {\n\t\t\t\tfor(var i = 0; i > octave3; i--) {\n\t\t\t\t\tfrequency3 /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tfrequency2 += detune2 > 0 ? ((frequency * 2) - frequency) * detune2 : (frequency - (frequency / 2)) * detune2;\n\t\t\tfrequency3 += detune3 > 0 ? ((frequency * 2) - frequency) * detune3 : (frequency - (frequency / 2)) * detune3;\n\t\t\t\t\t\t\t\n\t\t\tvar oscValue = osc1(frequency, amp1, pulsewidth) + osc2(frequency2, amp2, pulsewidth) + osc3(frequency3, amp3, pulsewidth);\n\t\t\tvar envResult = envelope(attack, decay) * velocity;\n\t\t\tvar val = filter( oscValue, cutoff + filterMult * envResult, resonance, isLowPass, 1) * envResult;\n\t\t\tval *= masterAmp;\n\t\t\tout[0] = out[1] = val;\n\t\t\treturn channels === 1 ? out : panner(val, pan, out);\n\t\t}else{\n\t\t\tout[0] = out[1] = 0;\n\t\t\treturn out;\n\t\t}\n\t}; \n  \n  this.init();\n  this.oscillatorInit();     \n\tthis.processProperties(arguments);\n};\nGibberish.MonoSynth.prototype = Gibberish._synth; \n\n/**#Gibberish.Binops - Miscellaneous\nThese objects create binary operations - mathematical operations taking two arguments - and create signal processing functions using them. They are primarily used for\nmodulation purposes. You can export the constructors for easier use similar to the [Time](javascript:displayDocs('Gibberish.Time'\\)) constructors.\n\nAdd, Sub, Mul and Div can actually take as many arguments as you wish. For example, Add(1,2,3,4) will return an object that outputs 10. You can stack multiple oscillators this way as well.\n\n##Example Usage   \n`// This example creates a tremolo effect via amplitude modulation  \nGibberish.Binops.export(); // now all constructors are also part of the window object  \nmod = new Gibberish.Sine(4, .25);  \nsin = new Gibberish.Sine( 440, add( .5, mod ) ).connect();  \n`\n**/\n\nGibberish.Binops = {\n/**###Gibberish.Binops.export : method  \nUse this to export the constructor methods of Gibberish.Binops so that you can tersely refer to them.\n\nparam **target** object, default window. The object to export the Gibberish.Binops constructors into.\n**/  \n  export: function(target) {\n    Gibberish.export(\"Binops\", target || window);\n  },\n  \n  operator : function () {\n    var me = new Gibberish.ugen(),\n        op = arguments[0],\n        args = Array.prototype.slice.call(arguments, 1);\n    \n    me.name = 'op';\n    me.properties = {};\n    for(var i = 0; i < args.length; i++) { \n      me.properties[i] = args[i]; \n    }\n    me.init.apply( me, args );\n    \n    me.codegen = function() {      \n      var keys, out = \"( \";\n      \n      if(typeof Gibberish.memo[this.symbol] !== 'undefined') { return Gibberish.memo[this.symbol]; }\n      \n      keys = Object.keys(this.properties);\n            \n      var shouldSkip = false;\n      for(var i = 0; i < keys.length; i++) {\n        if( shouldSkip ) { shouldSkip = false; continue; }\n                \n        var isObject = typeof this[i] === 'object';\n        \n        var shouldPush = false;\n        if(isObject) {\n          out += this[i].codegen();\n        }else{\n          out += this[i];\n        }\n        \n        if( ( op === '*' || op === '/' ) && this[ i + 1 ] === 1 ) { \n          shouldSkip = true; continue; \n        }\n        \n        if(i < keys.length - 1) { out += \" \" + op + \" \"; }\n        \n        //if( isObject && shouldPush ) Gibberish.codeblock.push(this[i].codeblock); \n      }\n      \n      out += \" )\";\n      \n      this.codeblock = out;\n      //Gibberish.memo[this.symbol] = out;\n      \n      return out;\n    };\n    \n    me.valueOf = function() { return me.codegen() }\n        \n    //me.processProperties.apply( me, args );\n\n    return me;\n  },\n  \n/**###Gibberish.Binops.Add : method  \nCreate an object that sums all arguments at audio rate. The arguments may be unit generators, numbers, or any mix of the two.\n**/\n  Add : function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('+');\n    \n    return Gibberish.Binops.operator.apply(null, args);\n  },\n\n/**###Gibberish.Binops.Sub : method  \nCreate an object that starts with the first argument and subtracts all subsequent arguments at audio rate. The arguments may be unit generators, numbers, or any mix of the two.\n**/\n  Sub : function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('-');\n    \n    return Gibberish.Binops.operator.apply(null, args);\n  },\n\n/**###Gibberish.Binops.Mul : method  \nCreate an object that calculates the product of all arguments at audio rate. The arguments may be unit generators, numbers, or any mix of the two.\n**/\n  Mul : function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('*');\n    \n    return Gibberish.Binops.operator.apply(null, args);\n  },\n\n/**###Gibberish.Binops.Div : method  \nCreate an object that takes the first argument and divides it by all subsequent arguments at audio rate. The arguments may be unit generators, numbers, or any mix of the two.\n**/\n  Div : function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('/');\n    \n    return Gibberish.Binops.operator.apply(null, args);\n  },\n\n/**###Gibberish.Binops.Mod : method  \nCreate an object that takes the divides the first argument by the second and returns the remainder at audio rate. The arguments may be unit generators, numbers, or any mix of the two.\n**/  \n  Mod : function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('%');\n    \n    return Gibberish.Binops.operator.apply(null, args);\n\n  },\n\n/**###Gibberish.Binops.Abs : method  \nCreate an object that returns the absolute value of the (single) argument. The argument may be a unit generator or number.\n**/  \n  Abs : function() {\n    var args = Array.prototype.slice.call(arguments, 0),\n    me = {\n      name : 'abs',\n      properties : {},\n      callback : Math.abs.bind( me ),\n    };\n    me.__proto__ = new Gibberish.ugen();\n    me.properties[0] = args[0];\n    me.init();\n\n    return me;\n  },\n/**###Gibberish.Binops.Sqrt : method  \nCreate an object that returns the square root of the (single) argument. The argument may be a unit generator or number.\n**/    \n  Sqrt : function() {\n    var args = Array.prototype.slice.call(arguments, 0),\n    me = {\n      name : 'sqrt',\n      properties : {},\n      callback : Math.sqrt.bind(me),\n    };\n    me.__proto__ = new Gibberish.ugen();    \n    me.properties[i] = arguments[0];\n    me.init();\n\n    return me;\n  },\n\n/**###Gibberish.Binops.Pow : method  \nCreate an object that returns the first argument raised to the power of the second argument. The arguments may be a unit generators or numbers.\n**/      \n  Pow : function() {\n    var args = Array.prototype.slice.call(arguments, 0),\n    me = {\n      name : 'pow',\n      properties : {},\n      callback : Math.pow.bind(me),\n    };\n    me.__proto__ = new Gibberish.ugen();\n  \n    for(var i = 0; i < args.length; i++) { me.properties[i] = args[i]; }\n    me.init();\n    \n    console.log( me.callback )\n    return me;\n  },\n  \n  Clamp : function() {\n    var args = Array.prototype.slice.call(arguments, 0),\n    me = {\n      name : 'clamp',\n      properties : { input:0, min:0, max:1 },\n      callback : function( input, min, max ) {\n        if( input < min ) {\n          input = min\n        }else if( input > max ) {\n          input = max\n        }\n        return input\n      },\n    };\n    me.__proto__ = new Gibberish.ugen();\n\n    me.init();\n    me.processProperties( args );\n\n    return me;\n  },\n  \n  Merge : function() {\n    var args = Array.prototype.slice.call(arguments, 0),\n    me = {\n      name : 'merge',\n      properties : {},\n      callback : function(a) {\n        return a[0] + a[1];\n      },\n    };\n    me.__proto__ = new Gibberish.ugen();\n  \n    for(var i = 0; i < args.length; i++) {\n      me.properties[i] = args[i];\n    }\n    me.init();\n\n    return me;\n  },\n            \n  Map : function( prop, _outputMin, _outputMax, _inputMin, _inputMax, _curve, _wrap) {\n    var pow = Math.pow,\n    LINEAR = 0,\n    LOGARITHMIC = 1,\n    base = 0,\n    phase = 0,\n    _value = 0,\n    me = {\n      name : 'map',\n      properties : { input:prop, outputMin:_outputMin, outputMax:_outputMax, inputMin:_inputMin, inputMax:_inputMax, curve:_curve || LINEAR, wrap: _wrap || false },\n      callback : function( v, v1Min, v1Max, v2Min, v2Max, curve, wrap ) {\n        var range1 = v1Max-v1Min,\n            range2 = v2Max - v2Min,\n            percent = (v - v2Min) / range2,\n            val \n        \n        if( percent > 1 ) {\n          percent = wrap ? percent % 1 : 1\n        }else if( percent < 0 ) {\n          percent = wrap ? 1 + (percent % 1) : 0\n        }\n        \n        val = curve === 0 ? v1Min + ( percent * range1 ) : v1Min + pow( percent, 1.5 ) * range1\n        \n        _value = val\n        // if(phase++ % 22050 === 0 ) console.log( _value, percent, v )\n        return val\n      },\n      // map_22(v_28, 0, 255, -1, 1, 0, false);\n      getValue: function() { return _value },\n      invert: function() {\n        var tmp = me.outputMin\n        me.outputMin = me.outputMax\n        me.outputMax = tmp\n      }\n    }\n  \n    me.__proto__ = new Gibberish.ugen()\n  \n    me.init()\n\n    return me\n  },\n};\n/**#Gibberish.Time - Miscellaneous\nThis object is used to simplify timing in Gibberish. It contains an export function to place its methods in another object (like window)\nso that you can code more tersely. The methods of the Time object translate ms, seconds and beats into samples. The default bpm is 120.\n\n##Example Usage   \n`Gibberish.Time.export(); // now all methods are also part of the window object\na = new Gibberish.Sine(440).connect();  \nb = new Gibberish.Sequencer({ target:a, key:'frequency', durations:[ seconds(1), ms(500), beats( .5 ) ], values:[220,440,880] }).start()  \n`\n**/\n\n/**###Gibberish.Time.bpm : property  \nNumber. Default 120. The beats per minute setting used whenever a call to the beats method is made.\n**/\n\n/**###Gibberish.Time.export : method  \nUse this to export the methods of Gibberish.Time so that you can tersely refer to them.\n\nparam **target** object, default window. The object to export the Gibberish.Time methods into.\n**/  \n\n/**###Gibberish.Time.ms : method  \nConvert the parameter from milliseconds to samples.\n\nparam **ms** number. The number of milliseconds to convert.\n**/  \n\n/**###Gibberish.Time.seconds : method  \nConvert the parameter from seconds to samples.\n\nparam **seconds** number. The number of seconds to convert.\n**/  \n\n/**###Gibberish.Time.beats : method  \nReturn a function that converts the parameter from beats to samples. This method uses the bpm property of the Gibberish.Time object to determine the duration of a sample.\nYou can use the function returned by this method in a Sequencer; if Gibberish.Time.bpm is changed before the function is executed the function will use the updated value.\n\nparam **seconds** number. The number of seconds to convert.\n**/  \n\nGibberish.Time = {\n  bpm: 120,\n  \n  export: function(target) {\n    Gibberish.export(\"Time\", target || window);\n  },\n  \n  ms : function(val) {\n    return val * Gibberish.context.sampleRate / 1000;\n  },\n  \n  seconds : function(val) {\n    return val * Gibberish.context.sampleRate;\n  },\n  \n  beats : function(val) {\n    return function() { \n      var samplesPerBeat = Gibberish.context.sampleRate / ( Gibberish.Time.bpm / 60 ) ;\n      return samplesPerBeat * val ;\n    }\n  },\n};\n/**#Gibberish.Sequencer - Miscellaneous\nA sample-accurate sequencer that can sequence changes to properties, method calls or anonymous function calls.\n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \nb = new Gibberish.Sequencer({ target:a, key:'note', durations:[11025, 22050], values:[440, 880] }).start()\n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the sequencer on initialization.\n- - - -\n**/\n/**###Gibberish.Sequencer.target : property  \nObject. An object for the sequencer to control. May be null if you are sequencing anonymous functions.\n**/\n/**###Gibberish.Sequencer.key : property  \nString. The name of the method or property you would like to sequnce on the Sequencer's target object.\n**/\n/**###Gibberish.Sequencer.durations : property  \nArray. The number of samples between each advancement of the Sequencer. Once the Sequencer arrives at the end of this list, it loops back to the beginning\n**/\n/**###Gibberish.Sequencer.keysAndValues : property  \nObject. A dictionary holding a set of values to be sequenced. The keys of the dictionary determine which methods and properties to sequence on the Sequencer's target object and\neach key has an array of values representing the sequence for that key.\n  \n`Gibberish.init();  \na = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \nb = new Gibberish.Sequencer({ target:a, durations:[11025, 22050], keysAndValues:{ 'note':[440,880], 'amp':[.2,.4] } }).start()\n`\n**/\n\nGibberish.Sequencer2 = function() {\n  var that = this,\n      phase = 0;\n  \n  Gibberish.extend(this, {\n    target        : null,\n    key           : null,\n    values        : null,\n    valuesIndex   : 0,\n    durations     : null,\n    durationsIndex: 0,\n    nextTime      : 0,\n    playOnce      : false,\n    repeatCount   : 0,\n    repeatTarget  : null,\n    isConnected   : true,\n    keysAndValues : null,\n    counts        : {},\n    properties    : { rate: 1, isRunning:false, nextTime:0 },\n    offset        : 0,\n    name          : 'seq',\n    \n    callback : function(rate, isRunning, nextTime) {\n      if(isRunning) {\n        if(phase >= nextTime) {\n          if(that.values !== null) {\n            if(that.target) {\n              var val = that.values[ that.valuesIndex++ ];\n              \n              if(typeof val === 'function') { val = val(); }\n              \n              if(typeof that.target[that.key] === 'function') {\n                that.target[that.key]( val );\n              }else{\n                that.target[that.key] = val;\n              }\n            }else{\n              if(typeof that.values[ that.valuesIndex ] === 'function') {\n                that.values[ that.valuesIndex++ ]();\n              }\n            }\n            if(that.valuesIndex >= that.values.length) that.valuesIndex = 0;\n          }else if(that.keysAndValues !== null) {\n            for(var key in that.keysAndValues) {\n              var index = that.counts[key]++;\n              var val = that.keysAndValues[key][index];\n              \n              if(typeof val === 'function') { val = val(); }\n              \n              if(typeof that.target[key] === 'function') {\n                that.target[key]( val );\n              }else{\n                that.target[key] = val;\n              }\n              if(that.counts[key] >= that.keysAndValues[key].length) {\n                that.counts[key] = 0;\n              }\n              if( that.chose ) that.chose( key, index )\n            }\n          }else if(typeof that.target[that.key] === 'function') {\n            that.target[that.key]();\n          }\n          \n          phase -= nextTime;\n        \n          if(Array.isArray(that.durations)) {\n            var next = that.durations[ that.durationsIndex++ ];\n            that.nextTime = typeof next === 'function' ? next() : next;\n            if( that.chose ) that.chose( 'durations', that.durationsIndex - 1 )\n            if( that.durationsIndex >= that.durations.length) {\n              that.durationsIndex = 0;\n            }\n          }else{\n            var next = that.durations;\n            that.nextTime = typeof next === 'function' ? next() : next;\n          }\n          \n          if(that.repeatTarget) {\n            that.repeatCount++;\n            if(that.repeatCount === that.repeatTarget) {\n              that.isRunning = false;\n              that.repeatCount = 0;\n            }\n          }\n          \n          return 0;\n        }\n      \n        phase += rate; //that.rate;\n      }\n      return 0;\n    },\n    \n/**###Gibberish.Sequencer.start : method  \nStart the sequencer running.\n\nparam **shouldKeepOffset** boolean, default false. If true, the phase of the sequencer will not be reset when calling the start method.\n**/     \n    start : function(shouldKeepOffset) {\n      if(!shouldKeepOffset) {\n        phase = 0;\n      }\n      \n      this.isRunning = true;\n      return this;\n    },\n\n/**###Gibberish.Sequencer.stop : method  \nStop the sequencer.\n**/     \n    stop: function() {\n      this.isRunning = false;\n      return this;\n    },\n    \n/**###Gibberish.Sequencer.repeat : method  \nPlay the sequencer a certain number of times and then stop it.\n\nparam **timesToRepeat** number. The number of times to repeat the sequence.\n**/        \n    repeat : function(times) {\n      this.repeatTarget = times;\n      return this;\n    },\n    \n    shuffle : function() {\n      for( key in this.keysAndValues ) {\n        this.shuffleArray( this.keysAndValues[ key ] )\n      }\n    },\n    \n    shuffleArray : function( arr ) {\n  \t\tfor(var j, x, i = arr.length; i; j = parseInt(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x);\n    },\n/**###Gibberish.Sequencer.disconnect : method  \nEach sequencer object has a tick method that is called once per sample. Use the disconnect method to stop the tick method from being called.\n**/     \n    /*disconnect : function() {\n      var idx = Gibberish.sequencers.indexOf( this );\n      Gibberish.sequencers.splice( idx, 1 );\n      this.isConnected = false;\n    },*/\n/**###Gibberish.Sequencer.connect : method  \nEach sequencer object has a tick method that is called once per sample. Use the connect method to start calling the tick method. Note that the connect\nmethod is called automatically when the sequencer is first created; you should only need to call it again if you call the disconnect method at some point.\n**/    \n    /*connect : function() {\n      if( Gibberish.sequencers.indexOf( this ) === -1 ) {\n        Gibberish.sequencers.push( this );\n      }\n      Gibberish.dirty( this )\n    },*/\n  });\n  \n  this.init( arguments );\n  this.processProperties( arguments );\n  \n  for(var key in this.keysAndValues) {\n    this.counts[key] = 0;\n  }\n  \n  this.oscillatorInit();\n  \n  phase += this.offset\n  \n  this.connect();\n};\nGibberish.Sequencer2.prototype = Gibberish._oscillator\n/**#Gibberish.Sequencer - Miscellaneous\nA sample-accurate sequencer that can sequence changes to properties, method calls or anonymous function calls.\n  \n## Example Usage##\n`Gibberish.init();  \na = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \nb = new Gibberish.Sequencer({ target:a, key:'note', durations:[11025, 22050], values:[440, 880] }).start()\n`  \n## Constructor   \n**param** *properties*: Object. A dictionary of property values (see below) to set for the sequencer on initialization.\n- - - -\n**/\n/**###Gibberish.Sequencer.target : property  \nObject. An object for the sequencer to control. May be null if you are sequencing anonymous functions.\n**/\n/**###Gibberish.Sequencer.key : property  \nString. The name of the method or property you would like to sequnce on the Sequencer's target object.\n**/\n/**###Gibberish.Sequencer.durations : property  \nArray. The number of samples between each advancement of the Sequencer. Once the Sequencer arrives at the end of this list, it loops back to the beginning\n**/\n/**###Gibberish.Sequencer.keysAndValues : property  \nObject. A dictionary holding a set of values to be sequenced. The keys of the dictionary determine which methods and properties to sequence on the Sequencer's target object and\neach key has an array of values representing the sequence for that key.\n  \n`Gibberish.init();  \na = new Gibberish.Synth({ attack:44, decay:44100 }).connect();  \nb = new Gibberish.Sequencer({ target:a, durations:[11025, 22050], keysAndValues:{ 'note':[440,880], 'amp':[.2,.4] } }).start()\n`\n**/\n\nGibberish.Sequencer = function() {  \n  Gibberish.extend(this, {\n    target        : null,\n    key           : null,\n    values        : null,\n    valuesIndex   : 0,\n    durations     : null,\n    durationsIndex: 0,\n    nextTime      : 0,\n    phase         : 0,\n    isRunning     : false,\n    playOnce      : false,\n    repeatCount   : 0,\n    repeatTarget  : null,\n    isConnected   : true,\n    keysAndValues : null,\n    counts        : {},\n    offset        : 0,\n    name          : 'seq',\n    \n    tick : function() {\n      if(this.isRunning) {\n        if(this.phase >= this.nextTime) {\n          if(this.values !== null) {\n            if(this.target) {\n              var val = this.values[ this.valuesIndex++ ];\n              \n              if(typeof val === 'function') { \n                try {\n                  val = val(); \n                }catch(e) {\n                  console.error('ERROR: Can\\'t execute function triggered by Sequencer:\\n' + val.toString() )\n                  this.values.splice( this.valuesIndex - 1, 1)\n                  this.valuesIndex--;\n                }\n              }\n              \n              if(typeof this.target[this.key] === 'function') {\n                this.target[this.key]( val );\n              }else{\n                this.target[this.key] = val;\n              }\n            }else{\n              if(typeof this.values[ this.valuesIndex ] === 'function') {\n                try {\n                  this.values[ this.valuesIndex++ ]();\n                }catch(e) {\n                  console.error('ERROR: Can\\'t execute function triggered by Sequencer:\\n' + this.values[ this.valuesIndex - 1 ].toString() )\n                  this.values.splice( this.valuesIndex - 1, 1)\n                  this.valuesIndex--;\n                }\n              }\n            }\n            if(this.valuesIndex >= this.values.length) this.valuesIndex = 0;\n          }else if(this.keysAndValues !== null) {\n            for(var key in this.keysAndValues) {\n              var index = typeof this.keysAndValues[ key ].pick === 'function' ? this.keysAndValues[ key ].pick() : this.counts[key]++;\n              var val = this.keysAndValues[key][index];\n              \n              if(typeof val === 'function') { \n                try {\n                  val = val(); \n                }catch(e) {\n                  console.error('ERROR: Can\\'t execute function triggered by Sequencer:\\n' + val.toString() )\n                  this.keysAndValues[key].splice( index, 1)\n                  if( typeof this.keysAndValues[ key ].pick !== 'function' ) {\n                    this.counts[key]--;\n                  }\n                }\n              }\n              \n              if(typeof this.target[key] === 'function') {\n                this.target[key]( val );\n              }else{\n                this.target[key] = val;\n              }\n              if(this.counts[key] >= this.keysAndValues[key].length) {\n                this.counts[key] = 0;\n              }\n            }\n          }else if(typeof this.target[this.key] === 'function') {\n            this.target[this.key]();\n          }\n          \n          this.phase -= this.nextTime;\n        \n          if(Array.isArray(this.durations)) {\n            var next = typeof this.durations.pick === 'function' ? this.durations[ this.durations.pick() ] : this.durations[ this.durationsIndex++ ];\n            this.nextTime = typeof next === 'function' ? next() : next;\n            if( this.durationsIndex >= this.durations.length) {\n              this.durationsIndex = 0;\n            }\n          }else{\n            var next = this.durations;\n            this.nextTime = typeof next === 'function' ? next() : next;\n          }\n          \n          if(this.repeatTarget) {\n            this.repeatCount++;\n            if(this.repeatCount === this.repeatTarget) {\n              this.isRunning = false;\n              this.repeatCount = 0;\n            }\n          }\n          \n          return;\n        }\n      \n        this.phase++\n      }\n    },\n\n/**###Gibberish.Sequencer.start : method  \nStart the sequencer running.\n\nparam **shouldKeepOffset** boolean, default false. If true, the phase of the sequencer will not be reset when calling the start method.\n**/     \n    start : function(shouldKeepOffset) {\n      if(!shouldKeepOffset) {\n        this.phase = this.offset;\n      }\n      \n      this.isRunning = true;\n      return this;\n    },\n\n/**###Gibberish.Sequencer.stop : method  \nStop the sequencer.\n**/     \n    stop: function() {\n      this.isRunning = false;\n      return this;\n    },\n    \n/**###Gibberish.Sequencer.repeat : method  \nPlay the sequencer a certain number of times and then stop it.\n\nparam **timesToRepeat** number. The number of times to repeat the sequence.\n**/        \n    repeat : function(times) {\n      this.repeatTarget = times;\n      return this;\n    },\n    \n    shuffle : function() {\n      for( key in this.keysAndValues ) {\n        this.shuffleArray( this.keysAndValues[ key ] )\n      }\n    },\n    \n    shuffleArray : function( arr ) {\n  \t\tfor(var j, x, i = arr.length; i; j = parseInt(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x);\n    },\n\n/**###Gibberish.Sequencer.disconnect : method  \nEach sequencer object has a tick method that is called once per sample. Use the disconnect method to stop the tick method from being called.\n**/     \n    disconnect : function() {\n      var idx = Gibberish.sequencers.indexOf( this );\n      Gibberish.sequencers.splice( idx, 1 );\n      this.isConnected = false;\n    },\n/**###Gibberish.Sequencer.connect : method  \nEach sequencer object has a tick method that is called once per sample. Use the connect method to start calling the tick method. Note that the connect\nmethod is called automatically when the sequencer is first created; you should only need to call it again if you call the disconnect method at some point.\n**/    \n    connect : function() {\n      if( Gibberish.sequencers.indexOf( this ) === -1 ) {\n        Gibberish.sequencers.push( this );\n      }\n      \n      this.isConnected = true\n      \n      return this\n    },\n  });\n  \n  for(var key in arguments[0]) {\n    this[key] = arguments[0][key];\n  }\n  \n  for(var key in this.keysAndValues) {\n    this.counts[key] = 0;\n  }\n  \n  this.connect();\n  \n  this.phase += this.offset\n  \n  //this.init( arguments );\n  //this.oscillatorInit();\n  //this.processProperties( arguments );\n};\nGibberish.Sequencer.prototype = Gibberish._oscillator\n// TODO: must fix scale seq\n\n/*\nc = new Gibberish.Synth({ pan:-1 }).connect();\nb = new Gibberish.Synth({ pan:1 }).connect(); \na = new Gibberish.PolySeq({ \n  seqs:[\n    { key:'note', target:b, values:[440,880], durations:22050 },\n    { key:'note', target:c, values:[220,1320], durations:[11025, 22050, 5512.5] },\n  ] \n}).start()\n*/\nGibberish.PolySeq = function() {\n  var that = this,\n      phase = 0,\n      sort = function(a,b) { if( a < b ) return -1; if( a > b ) return 1; return 0; } ;\n  \n  Gibberish.extend(this, {\n    seqs          : [],\n    autofire      : [], // seqs with no scheduling that fire everytime a scheduled seq is triggered    \n    timeline      : {},\n    playOnce      : false,\n    repeatCount   : 0,\n    repeatTarget  : null,\n    isConnected   : false,\n    properties    : { rate: 1, isRunning:false, nextTime:0 },\n    offset        : 0,\n    name          : 'polyseq',\n    getPhase      : function() { return phase },\n    setPhase      : function(v) { phase = v },\n    adjustPhase   : function(v) { phase += v },\n    timeModifier  : null,\n    add           : function( seq, pos ) {\n      seq.valuesIndex = seq.durationsIndex = 0\n\n      if( seq.durations === null ) {\n        seq.autofire = true\n        that.autofire.push( seq )\n      }else{\n        if( typeof pos === 'undefined' ) {\n          that.seqs.push( seq )\n        }else{\n          that.seqs.splice( pos, 0, seq )\n        }\n        \n        if( typeof that.timeline[ phase ] !== 'undefined' ) {\n          if( seq.priority ) {\n            that.timeline[ phase ].unshift( seq )\n          }else{\n            that.timeline[ phase ].push( seq )\n          }\n        }else{\n          that.timeline[ phase ] = [ seq ]\n        }\n        \n        that.nextTime = phase\n      }\n      // for Gibber... TODO: remove from Gibberish\n      if( that.scale && (seq.key === 'frequency' || seq.key === 'note') ) {\n        if( that.applyScale ) {\n          that.applyScale()\n        }\n      }\n\n      seq.shouldStop = false\n    },\n    \n    callback : function(rate, isRunning, nextTime) {\n      var newNextTime;\n      \n      if(isRunning) {\n        if(phase >= nextTime) {\n          var seqs = that.timeline[ nextTime ],\n              phaseDiff = phase - nextTime\n              \n          if( typeof seqs === 'undefined') return\n                    \n          for( var j = 0; j < seqs.length; j++ ) {\n            var seq = seqs[ j ]\n            if( seq.shouldStop ) continue;\n\n            var idx = seq.values.pick ? seq.values.pick() : seq.valuesIndex++ % seq.values.length\n            \n            var val = typeof seq.values === 'function' ? seq.values() : seq.values[ idx ];\n    \n            if(typeof val === 'function') { val = val(); } // will also call anonymous function\n    \n            if( seq.target ) {\n              if( typeof seq.target[ seq.key ] === 'function' ) {\n                seq.target[ seq.key ]( val );\n              }else{\n                seq.target[ seq.key ] = val;\n              }\n            }\n            \n            if( that.chose ) that.chose( seq.key, idx )\n             \n            if( Array.isArray( seq.durations ) ) {\n              var idx = seq.durations.pick ? seq.durations.pick() : seq.durationsIndex++,\n                  next = typeof seq.durations === 'function' ? seq.durations() : seq.durations[ idx ]\n\n              newNextTime = typeof next === 'function' ? next() : next;\n              if( typeof seq.durations !== 'function' && seq.durationsIndex >= seq.durations.length ) {\n                seq.durationsIndex = 0;\n              }\n              if( that.chose ) that.chose( 'durations', idx )\n            }else{\n              var next = typeof seq.durations === 'function' ? seq.durations() : seq.durations;\n              \n              newNextTime = typeof next === 'function' ? next() : next;\n            }\n        \n            var t;\n          \n            if( that.timeModifier !== null ) {\n              t = that.timeModifier( newNextTime ) + phase // TODO: remove Gibber link... how?\n            }else{\n              t = newNextTime + phase\n            }\n          \n            t -= phaseDiff\n            newNextTime -= phaseDiff\n          \n            if( typeof that.timeline[ t ] === 'undefined' ) {\n              that.timeline[ t ] = [ seq ]\n            }else{\n              if( seq.priority ) {\n                that.timeline[ t ].unshift( seq )\n              }else{\n                that.timeline[ t ].push( seq )\n              }\n            }\n          }\n          \n          for( var j = 0, l = that.autofire.length; j < l; j++ ) {\n            var seq = that.autofire[ j ]\n            if( seq.shouldStop ) continue;\n\n            var idx = seq.values.pick ? seq.values.pick() : seq.valuesIndex++ % seq.values.length,\n                val = seq.values[ idx ];\n    \n            if(typeof val === 'function') { val = val(); } // will also call anonymous function\n    \n            if( seq.target ) {\n              if(typeof seq.target[ seq.key ] === 'function') {\n                seq.target[ seq.key ]( val );\n              }else{\n                seq.target[ seq.key ] = val;\n              }\n            }\n            \n            if( that.chose ) that.chose( seq.key, idx )\n          }\n          \n          delete that.timeline[ nextTime ]\n          \n          var times = Object.keys( that.timeline ),\n              timesLength = times.length;\n          \n          if( timesLength > 1 ) {\n            for( var i = 0; i < timesLength; i++ ) {\n              times[ i ] = parseFloat( times[i] )\n            }\n          \n            times = times.sort( sort )\n            that.nextTime = times[0]\n          }else{\n            that.nextTime = parseFloat( times[0] )\n          }\n          \n          // if(that.repeatTarget) {\n          //   that.repeatCount++;\n          //   if(that.repeatCount === that.repeatTarget) {\n          //     that.isRunning = false;\n          //     that.repeatCount = 0;\n          //   }\n          // }  \n        }\n        \n        // TODO: If you set the phase to 0, it will be lower than nextTime for many many samples in a row, causing it to quickly skip\n        // through lots of key / value pairs.\n        \n        phase += rate;\n      }\n      return 0;\n    },\n  \n    start : function(shouldKeepOffset, priority) {\n      if(!shouldKeepOffset || ! this.offset ) {\n        phase = 0;\n        this.nextTime = 0;\n        \n        this.timeline = { 0:[] }\n        for( var i = 0; i < this.seqs.length; i++ ) {\n          var _seq = this.seqs[ i ]\n    \n          _seq.valuesIndex = _seq.durationsIndex = _seq.shouldStop = 0\n    \n          this.timeline[ 0 ].push( _seq )\n        }\n      }else{\n        phase = 0;\n        this.nextTime = this.offset;\n        \n        var ___key = ''+this.offset\n        \n        this.timeline = {}\n        this.timeline[ ___key ] = []\n\n        for( var i = 0; i < this.seqs.length; i++ ) {\n          var _seq = this.seqs[ i ]\n    \n          _seq.valuesIndex = _seq.durationsIndex = _seq.shouldStop = 0\n    \n          this.timeline[ ___key ].push( _seq )\n        }\n      }\n      \n      if( !this.isConnected ) {\n        this.connect( Gibberish.Master, priority )\n        this.isConnected = true\n      }\n      \n      this.isRunning = true;\n      return this;\n    },\n    \n    stop: function() {\n      this.isRunning = false;\n      \n      if( this.isConnected ) {\n        this.disconnect()\n        this.isConnected = false\n      }\n      return this;\n    },\n       \n    repeat : function(times) {\n      this.repeatTarget = times;\n      return this;\n    },\n    \n    shuffle : function( seqName ) {\n      if( typeof seqName !== 'undefined' ) {\n        for( var i = 0; i < this.seqs.length; i++ ) {\n          if( this.seqs[i].key === seqName ) {\n            this.shuffleArray( this.seqs[i].values )\n          }\n        }\n      }else{\n        for( var i = 0; i < this.seqs.length; i++ ) {\n          this.shuffleArray( this.seqs[i].values )\n        }\n      }\n    },\n    \n    shuffleArray : function( arr ) {\n  \t\tfor(var j, x, i = arr.length; i; j = parseInt(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x);\n    },\n\n  });\n  \n  this.init( arguments );\n  this.processProperties( arguments );\n  \n  this.oscillatorInit();\n};\nGibberish.PolySeq.prototype = Gibberish._oscillator\nvar _hasInput = false; // wait until requested to ask for permissions so annoying popup doesn't appear automatically\n\nif( typeof navigator === 'object' ) {\n  navigator.getUserMedia = ( navigator.getUserMedia       ||\n                             navigator.webkitGetUserMedia ||\n                             navigator.mozGetUserMedia    ||\n                             navigator.msGetUserMedia )\n}\n                           \nfunction createInput() {\n  console.log(\"connecting audio input...\");\n  \n  navigator.getUserMedia(\n\t\t{audio:true}, \n\t\tfunction (stream) {\n      console.log( 'audio input connected' )\n\t    Gibberish.mediaStreamSource = Gibberish.context.createMediaStreamSource( stream );\n\t    Gibberish.mediaStreamSource.connect( Gibberish.node );\n\t\t\t_hasInput = true;\n\t\t},\n    function( e ) { \n      console.log( e )\n      console.log( 'error opening audio input')\n    }\n\t)\n}\n/**#Gibberish.Input - Oscillator\nAccept input from computer's line-in or microphone input. Use headphones and beware feedback! Reading the audio input is currently only supported by Google Chrome.\n\n## Example Usage##\n`\nGibberish.init();  \na = new Gibberish.Input()  \nb = new Gibberish.Delay( a ).connect()  \n- - - -\n**/\n/**###Gibberish.Input.amp : property  \nNumber. A gain multiplier for the input\n**/\n\nGibberish.Input = function() {\n  var out = [], phase = 0;\n  \n\tif(!_hasInput) { \n\t\tcreateInput(); \n\t}\n  \n  this.type = this.name = 'input'\n  \n  this.fx = new Array2() \n  this.fx.parent = this\n  \n  this.properties = {\n    input : 'input',\n    amp : .5,  \n    channels : 1,\n  }\n  \n  this.callback = function(input, amp, channels) {\n    if(channels === 1) {\n      out = input * amp;\n    }else {\n      out[0] = input[0] * amp;\n      out[1] = input[1] * amp;      \n    }\n    return out;\n  }\n  \n  this.init( arguments )\n  this.processProperties( arguments )\n};\nGibberish.Input.prototype = new Gibberish.ugen();\nGibberish.Kick = function() {\n  var trigger = false,\n    \tbpf = new Gibberish.SVF().callback,\n    \tlpf = new Gibberish.SVF().callback,\n      _decay = .2,\n      _tone = .8;\n      \n  Gibberish.extend(this, {\n  \tname:\t\t\"kick\",\n    properties:\t{ pitch:50, __decay:20, __tone: 1000, amp:2, sr: Gibberish.context.sampleRate },\n\t\n  \tcallback: function(pitch, decay, tone, amp, sr) {\t\t\t\t\t\n  \t\tvar out = trigger ? 60 : 0;\n\t\t\t\n  \t\tout = bpf( out, pitch, decay, 2, sr );\n  \t\tout = lpf( out, tone, .5, 0, sr );\n\t\t\n  \t\tout *= amp;\n\t\t\n  \t\ttrigger = false;\n\t\t\n  \t\treturn out;\n  \t},\n\n  \tnote : function(p, d, t, amp) {\n  \t\tif(typeof p === 'number') this.pitch = p;\n  \t\tif(typeof d === 'number') this.decay = d;\n  \t\tif(typeof t === 'number') this.tone = t;\n  \t\tif(typeof amp === 'number') this.amp = amp;\n\t\t\n      trigger = true;\n  \t},\n  })\n  .init()\n  .oscillatorInit();\n  \n  Object.defineProperties(this, {\n    decay :{\n      get: function() { return _decay; },\n      set: function(val) { _decay = val > 1 ? 1 : val; this.__decay = _decay * 100; }\n    },\n    tone :{\n      get: function() { return _tone; },\n      set: function(val) { _tone = val > 1 ? 1 : val; this.__tone = 220 + val * 1400;  }\n    },\n  });\n  \n  this.processProperties(arguments);\n};\nGibberish.Kick.prototype = Gibberish._oscillator;\n\n// congas are bridged t-oscillators like kick without the low-pass filter\nGibberish.Conga = function() {\n  var trigger = false,\n    \tbpf = new Gibberish.SVF().callback,\n      _decay = .5;\n      \n  Gibberish.extend(this, {\n  \tname:\t\t\"conga\",\n    properties:\t{ pitch:190, /*__decay:50,*/ amp:2, sr:Gibberish.context.sampleRate },\n\t\n  \tcallback: function(pitch, /*decay,*/ amp, sr) {\t\t\t\t\t\n  \t\tvar out = trigger ? 60 : 0;\n\t\t\t\n  \t\tout = bpf( out, pitch, 50, 2, sr );\n\t\t\n  \t\tout *= amp;\n\t\t\n  \t\ttrigger = false;\n\t\t\n  \t\treturn out;\n  \t},\n\n  \tnote : function(p, amp) {\n  \t\tif(typeof p === 'number') this.pitch = p;\n  \t\tif(typeof amp === 'number') this.amp = amp;\n\t\t\n      trigger = true;\n  \t},\n  })\n  .init()\n  .oscillatorInit();\n\n  // Object.defineProperties(this, {\n  //   decay :{\n  //     get: function() { return _decay; },\n  //     set: function(val) { _decay = val > 1 ? 1 : val; this.__decay = _decay * 100; }\n  //   }\n  // });\n  // \n  this.processProperties(arguments);\n}\nGibberish.Conga.prototype = Gibberish._oscillator;\n\n// clave are also bridged t-oscillators like kick without the low-pass filter\nGibberish.Clave = function() {\n  var trigger = false,\n    \t_bpf = new Gibberish.SVF(),\n      bpf = _bpf.callback,\n      _decay = .5;\n      \n  Gibberish.extend(this, {\n  \tname:\t\t\"clave\",\n    properties:\t{ pitch:2500, /*__decay:50,*/ amp:1, sr:Gibberish.context.sampleRate },\n\t\n  \tcallback: function(pitch, /*decay,*/ amp, sr) {\t\t\t\t\t\n  \t\tvar out = trigger ? 2 : 0;\n\t\t\t\n  \t\tout = bpf( out, pitch, 5, 2, sr );\n\t\t\n  \t\tout *= amp;\n\t\t\n  \t\ttrigger = false;\n\t\t\n  \t\treturn out;\n  \t},\n\n  \tnote : function(p, amp) {\n  \t\tif(typeof p === 'number') this.pitch = p;\n  \t\tif(typeof amp === 'number') this.amp = amp;\n\t\t\n      trigger = true;\n  \t},\n  })\n  .init()\n  .oscillatorInit();\n  \n  this.bpf = _bpf;\n  // Object.defineProperties(this, {\n  //   decay :{\n  //     get: function() { return _decay; },\n  //     set: function(val) { _decay = val > 1 ? 1 : val; this.__decay = _decay * 100; }\n  //   }\n  // });\n  // \n  this.processProperties(arguments);\n}\nGibberish.Clave.prototype = Gibberish._oscillator;\n\n// tom is tbridge with lpf'd noise\nGibberish.Tom = function() {\n  var trigger = false,\n    \tbpf = new Gibberish.SVF().callback,\n    \tlpf = new Gibberish.SVF().callback,\n      _eg = new Gibberish.ExponentialDecay(),\n      eg  = _eg.callback,\n      rnd = Math.random,\n      _decay = .2,\n      _tone = .8;\n      \n  Gibberish.extend(this, {\n  \tname:\t\t\"tom\",\n    properties:\t{ pitch:80, amp:.5, sr:Gibberish.context.sampleRate },\n\t\n  \tcallback: function(pitch, amp, sr) {\t\t\t\t\t\n  \t\tvar out = trigger ? 60 : 0,\n          noise;\n\t\t\t\n  \t\tout = bpf( out, pitch, 30, 2, sr );\n      \n      noise = rnd() * 16 - 8\n\t\t  noise = noise > 0 ? noise : 0;\n      \n      noise *= eg(.05, 11025);\n      \n  \t\tnoise = lpf( noise, 120, .5, 0, sr );\n      \n      out += noise;\n  \t\tout *= amp;\n\t\t\n  \t\ttrigger = false;\n\t\t\n  \t\treturn out;\n  \t},\n\n  \tnote : function(p, amp) {\n  \t\tif(typeof p === 'number') this.pitch = p;\n  \t\tif(typeof amp === 'number') this.amp = amp;\n\t\t  \n      _eg.trigger();\n      trigger = true;\n  \t},\n  })\n  .init()\n  .oscillatorInit();\n  \n  _eg.trigger(1)\n  \n  this.processProperties(arguments);\n}\nGibberish.Tom.prototype = Gibberish._oscillator;\n\nGibberish.Clap = function() {\n  var _bpf = new Gibberish.Biquad(),\n      bpf  = _bpf.callback,\n      _bpf2 = new Gibberish.Biquad(),\n      bpf2 = _bpf2.callback,\n      _bpf3 = new Gibberish.Biquad(),\n      bpf3 = _bpf3.callback,      \n      _eg = new Gibberish.ExponentialDecay(),\n      eg  = _eg.callback,\n      _eg2 = new Gibberish.ExponentialDecay(),\n      eg2 = _eg2.callback,\n      _ad  = new Gibberish.Line(),\n      ad = _ad.callback,\n      _lfo = new Gibberish.Saw(),\n      lfo = _lfo.callback,\n      rnd = Math.random,\n      cutoff = 1000,\n      rez = 2.5,\n      env1K = .025,\n      env2K = .9,\n      env1Dur = 30 * 44.1,\n      env2Dur = 660,\n      freq = 100\n      \n  _bpf.mode = _bpf2.mode = 'BP'\n  _bpf3.mode = 'BP'\n  _bpf3.cutoff = 2400\n  \n  _bpf.cutoff = _bpf2.cutoff = 1000\n  _bpf.Q = 2\n  _bpf2.Q = 1\n      \n  Gibberish.extend(this, {\n  \tname:\t\t\"clap\",\n    properties:\t{ amp:.5, sr:Gibberish.context.sampleRate },\n\t\n  \tcallback: function( amp, sr ) {\n  \t\tvar out = 0, noiseBPF, noise, env;\n\t\t\t      \n      noiseBPF = rnd() * 4 - 2 //* 4 - 2\n\t\t  noiseBPF = noiseBPF > 0 ? noiseBPF : 0;\n      \n      noise = rnd() * 4 - 2 //* 16 - 8\n\t\t  noise = noise > 0 ? noise : 0;\n      \n  \t\tout = bpf2( bpf( noiseBPF ) ) //, cutoff, rez, 2, sr ); // mode 2 is bp\n      \n      out *= eg2( env2K, env2Dur )\n      \n      noise = bpf3( lfo( freq, noise ) * eg( env1K, env1Dur ) )//ad( 1,0, env1Dur, false ) );\n      \n      out += noise;\n  \t\tout *= amp;\n\t\t\n  \t\treturn out;\n  \t},\n\n  \tnote : function( amp ) {\n  \t\tif(typeof amp === 'number') this.amp = amp;\n\t\t  \n      _eg2.trigger();\n      _eg.trigger();\n      _ad.setPhase(0);\n      _lfo.setPhase(0);\n\n  \t},\n  })\n  .init()\n  .oscillatorInit();\n  \n  // _eg.trigger(1)\n  // _eg2.trigger(1)\n  \n  this.getBPF = function() { return _bpf; }\n  this.getBPF2 = function() { return _bpf2; }\n  this.getBPF3 = function() { return _bpf3; }\n  this.getLine = function() { return _ad; }\n  \n  this.setEnvK = function( k1,k2,d1,d2 ) {\n    env1K = k1\n    if( k2 ) env2K = k2\n    if( d1 ) env1Dur = d1\n    if( d2 ) env2Dur = d2    \n  }\n  \n  this.setFreq = function(v) { freq = v }\n  \n  this.setRez = function(v) { rez = v; }\n  this.setCutoff = function(v) { cutoff = v; }  \n  \n  this.processProperties(arguments);\n}\nGibberish.Clap.prototype = Gibberish._oscillator;\n\n// http://www.soundonsound.com/sos/Sep02/articles/synthsecrets09.asp\nGibberish.Cowbell = function() {\n  var _s1 = new Gibberish.Square(),\n      _s2 = new Gibberish.Square(),\n      s1 = _s1.callback,\n      s2 = _s2.callback,                              \n\n      _bpf = new Gibberish.SVF({ mode:2 }),\n      bpf   = _bpf.callback,\n\n      _eg   = new Gibberish.ExponentialDecay( .0025, 10500 ),\n      eg    = _eg.callback;\n  \n  Gibberish.extend(this, {\n  \tname: \"cowbell\",\n  \tproperties : { amp: 1, pitch: 560, bpfFreq:1000, bpfRez:3, decay:22050, decayCoeff:.0001, sr:Gibberish.context.sampleRate },\n\t\n  \tcallback : function(amp, pitch, bpfFreq, bpfRez, decay, decayCoeff, sr) {\n  \t\tvar val;\n      \n  \t\tval =  s1( pitch, 1, 1, 0 );\n  \t\tval += s2( 845, 1, 1, 0 );\n\t\t\n      val  = bpf(  val, bpfFreq, bpfRez, 2, sr );\n      \t\t\n      val *= eg(decayCoeff, decay);\n  \n  \t\tval *= amp;\n\t\t  \n  \t\treturn val;\n  \t},\n\t\n  \tnote : function(_decay, _decay2) {\n      _eg.trigger()\n  \t\tif(_decay)\n  \t\t\tthis.decay = _decay;\n  \t}\n  })\n  .init()\n  .oscillatorInit()\n  .processProperties(arguments);\n  \n  this.bpf = _bpf;\n  this.eg = _eg;\n  \n  _eg.trigger(1);\n};\nGibberish.Cowbell.prototype = Gibberish._oscillator;\n\nGibberish.Snare = function() {\n  var bpf1      = new Gibberish.SVF().callback,\n      bpf2      = new Gibberish.SVF().callback,\n      noiseHPF  = new Gibberish.SVF().callback,\n      _eg       = new Gibberish.ExponentialDecay( .0025, 11025 ),\n      eg        = _eg.callback,            \n      rnd       = Math.random,\n      phase  = 11025,      \n      out    = 0,\n      envOut = 0;\n      \n  Gibberish.extend(this, {\n  \tname: \"snare\",\n  \tproperties: { cutoff:1000, decay:11025, tune:0, snappy:.5, amp:1, sr:Gibberish.context.sampleRate },\n\n  \tcallback: function(cutoff, decay, tune, snappy, amp, sr) {\n  \t\tvar p1, p2, noise = 0, env = 0, out = 0;\n\n  \t\tenv = eg(.0025, decay);\n\t\t\n  \t\tif(env > .005) {\t\n  \t\t\tout = ( rnd() * 2 - 1 ) * env ;\n  \t\t\tout = noiseHPF( out, cutoff + tune * 1000, .5, 1, sr );\n  \t\t\tout *= snappy;\n        \n        // rectify as per instructions found here: http://ericarcher.net/devices/tr808-clone/\n        out = out > 0 ? out : 0;\n        \n  \t\t\tenvOut = env;\n\t\t\t\n  \t\t\tp1 = bpf1( envOut, 180 * (tune + 1), 15, 2, sr );\n  \t\t\tp2 = bpf2( envOut, 330 * (tune + 1), 15, 2, sr );\n\t\t\n  \t\t\tout += p1; \n  \t\t\tout += p2 * .8;\n  \t\t\tout *= amp;\n  \t\t}\n\n  \t\treturn out;\n  \t},\n\n  \tnote : function(t, amp, s, c) {\n      if(typeof t === 'number')   this.tune = t;\t\t\t\t\t      \n  \t\tif(typeof c === 'number')   this.cutoff = c;\t\t\t\t\t\n  \t\tif(typeof s === 'number')   this.snappy = s; \n  \t\tif(typeof amp === 'number') this.amp = amp;\n\t\t\n  \t\t_eg.trigger()\n  \t},\n  })\n  .init()\n  .oscillatorInit()\n  .processProperties(arguments);\n  \n  _eg.trigger(1);\n}\nGibberish.Snare.prototype = Gibberish._oscillator;\n\nGibberish.Hat = function() {\n  var _s1 = new Gibberish.Square(),\n      _s2 = new Gibberish.Square(),\n      _s3 = new Gibberish.Square(),\n      _s4 = new Gibberish.Square(),\n      _s5 = new Gibberish.Square(),\n      _s6 = new Gibberish.Square(),\n      s1 = _s1.callback,\n      s2 = _s2.callback,\n      s3 = _s3.callback,\n      s4 = _s4.callback,\n      s5 = _s5.callback,\n      s6 = _s6.callback,                              \n      //_bpf = new Gibberish.Biquad({ mode:'BP' }),\n      _bpf = new Gibberish.SVF({ mode:2 }),\n      bpf   = _bpf.callback,\n      _hpf  = new Gibberish.Filter24(),\n      hpf   = _hpf.callback,\n      _eg   = new Gibberish.ExponentialDecay( .0025, 10500 ),\n      eg    = _eg.callback,\n      _eg2   = new Gibberish.ExponentialDecay( .1, 7500 ),\n      eg2    = _eg2.callback;        \n  \n  Gibberish.extend(this, {\n  \tname: \"hat\",\n  \tproperties : { amp: 1, pitch: 325, bpfFreq:7000, bpfRez:2, hpfFreq:.975, hpfRez:0, decay:3500, decay2:3000, sr:Gibberish.context.sampleRate },\n\t\n  \tcallback : function(amp, pitch, bpfFreq, bpfRez, hpfFreq, hpfRez, decay, decay2, sr) {\n  \t\tvar val;\n      \n  \t\tval =  s1( pitch, 1, .5, 0 );\n  \t\tval += s2( pitch * 1.4471, .75, 1, 0 );\n  \t\tval += s3( pitch * 1.6170, 1, 1, 0 );\n  \t\tval += s4( pitch * 1.9265, 1, 1, 0 );\n  \t\tval += s5( pitch * 2.5028, 1, 1, 0 );\n  \t\tval += s6( pitch * 2.6637, .75, 1, 0 );\n\t\t\n      val  = bpf(  val, bpfFreq, bpfRez, 2, sr );\n      \t\t\n  \t\tval  *= eg(.001, decay);\n      \n      // rectify as per instructions found here: http://ericarcher.net/devices/tr808-clone/\n      // val = val > 0 ? val : 0;\n        \t\t\n  \t\t//sample, cutoff, resonance, isLowPass, channels\n  \t\tval \t= hpf(val, hpfFreq, hpfRez, 0, 1 );\n  \n  \t\tval *= amp;\n\t\t  \n  \t\treturn val;\n  \t},\n\t\n  \tnote : function(_decay, _decay2) {\n  \t\t_eg.trigger()\n  \t\t_eg2.trigger()\n  \t\tif(_decay)\n  \t\t\tthis.decay = _decay;\n  \t\tif(_decay2)\n  \t\t\tthis.decay2 = _decay2;\n\t\t\n  \t}\n  })\n  .init()\n  .oscillatorInit()\n  .processProperties(arguments);\n  \n  this.bpf = _bpf;\n  this.hpf = _hpf;\n  \n  _eg.trigger(1);\n  _eg2.trigger(1);\n};\nGibberish.Hat.prototype = Gibberish._oscillator;\n\n/* IMPORTANT README\n*\n* This class depends on having access to a folder of soundfonts that have been converted to\n* binary string representations. More specifically, soundfonts designed to work with GenMIDI.js:\n*\n* https://github.com/gleitz/midi-js-soundfonts\n*\n* At some point it would be nice to make another soundfont system, as GenMIDI.js does not support\n* defining loop points.\n*\n* By default soundfonts should be found in a folder named 'resources/soundfonts' one level above\n* the location of the gibberish.js library (or gibberish.min.js). You can pass a different path\n* as the second argument to the Gibberish.SoundFont constructor; the first is the name of the soundfont\n* minus the \"-mp3.js\" extension. So, for example:\n*\n* b = new Gibberish.SoundFont( 'choir_aahs' ).connect()\n* b.note( 'C4' )\n*\n* Note that you can only use note names, not frequency values.\n*/\n\n(function() {\n  var cents = function(base, _cents) { return base * Math.pow(2,_cents/1200) },\n      GenMIDI = { Soundfont: { instruments: {} } },\n      SF = GenMIDI.Soundfont\n  \n  // TODO: GET RID OF THIS GLOBAL!!!! It's unfortunately in there because we're using soundfonts meant for GenMIDI.js\n  if( typeof window === 'object' )\n    window.GenMIDI = GenMIDI\n  else\n    global.GenMIDI = GenMIDI\n  \n  var getScript = function( scriptPath, handler ) {\n    var oReq = new XMLHttpRequest();\n    \n    oReq.addEventListener(\"load\", transferComplete, false);\n    oReq.addEventListener(\"error\", function(e){ console.log( \"SF load error\", e ) }, false);\n\n    oReq.open( 'GET', scriptPath, true );\n    oReq.send()\n\n    function updateProgress (oEvent) {\n      if (oEvent.lengthComputable) {\n        var percentComplete = oEvent.loaded / oEvent.total;\n        number.innerHTML = Math.round( percentComplete * 100 )\n\n        var sizeString = new String( \"\" + oEvent.total )\n        sizeString = sizeString[0] + '.' + sizeString[1] + ' MB'\n        size.innerHTML = sizeString\n        \n        console.log( percentComplete, \"%\" )\n      } else {\n        // Unable to compute progress information since the total size is unknown\n      }\n    }\n\n    function transferComplete( evt ) {\n      console.log(\"COMPLETE\", scriptPath)\n      var script = document.createElement('script')\n      script.innerHTML = evt.srcElement ? evt.srcElement.responseText : evt.target.responseText\n      document.querySelector( 'head' ).appendChild( script )\n      handler( script ) \n    }\n  }\n  \n  var Base64Binary = {\n  \t_keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n\t\n  \t// will return a  Uint8Array type\n  \tdecodeArrayBuffer: function(input) {\n  \t\tvar bytes = (input.length/4) * 3;\n  \t\tvar ab = new ArrayBuffer(bytes);\n  \t\tthis.decode(input, ab);\n\t\t\n  \t\treturn ab;\n  \t},\n\t\n  \tdecode: function(input, arrayBuffer) {\n  \t\t//get last chars to see if are valid\n  \t\tvar lkey1 = this._keyStr.indexOf(input.charAt(input.length-1));\t\t \n  \t\tvar lkey2 = this._keyStr.indexOf(input.charAt(input.length-2));\t\t \n\t\n  \t\tvar bytes = (input.length/4) * 3;\n  \t\tif (lkey1 == 64) bytes--; //padding chars, so skip\n  \t\tif (lkey2 == 64) bytes--; //padding chars, so skip\n\t\t\n  \t\tvar uarray;\n  \t\tvar chr1, chr2, chr3;\n  \t\tvar enc1, enc2, enc3, enc4;\n  \t\tvar i = 0;\n  \t\tvar j = 0;\n\t\t\n  \t\tif (arrayBuffer)\n  \t\t\tuarray = new Uint8Array(arrayBuffer);\n  \t\telse\n  \t\t\tuarray = new Uint8Array(bytes);\n\t\t\n  \t\tinput = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\t\t\n  \t\tfor (i=0; i<bytes; i+=3) {\t\n  \t\t\t//get the 3 octects in 4 ascii chars\n  \t\t\tenc1 = this._keyStr.indexOf(input.charAt(j++));\n  \t\t\tenc2 = this._keyStr.indexOf(input.charAt(j++));\n  \t\t\tenc3 = this._keyStr.indexOf(input.charAt(j++));\n  \t\t\tenc4 = this._keyStr.indexOf(input.charAt(j++));\n\t\n  \t\t\tchr1 = (enc1 << 2) | (enc2 >> 4);\n  \t\t\tchr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n  \t\t\tchr3 = ((enc3 & 3) << 6) | enc4;\n\t\n  \t\t\tuarray[i] = chr1;\t\t\t\n  \t\t\tif (enc3 != 64) uarray[i+1] = chr2;\n  \t\t\tif (enc4 != 64) uarray[i+2] = chr3;\n  \t\t}\n\t\n  \t\treturn uarray;\t\n  \t}\n  }\n  \n  var decodeBuffers = function( obj ) {\n    var count = 0,\n        font = SF[ obj.instrumentFileName ]\n        \n    if( typeof SF.instruments[ obj.instrumentFileName ] === 'undefined' ) {\n      SF.instruments[ obj.instrumentFileName ] = {}\n    }\n    \n    obj.buffers = SF.instruments[ obj.instrumentFileName ]\n    \n    for( var note in font ) {\n      count++\n      !function() {\n        var _note = note\n        \n        var base = font[ _note ].split(\",\")[1]\n        var arrayBuffer = Base64Binary.decodeArrayBuffer( base );\n        \n        Gibberish.context.decodeAudioData( arrayBuffer, function( _buffer ) {\n          SF.instruments[ obj.instrumentFileName ][ _note ] = _buffer.getChannelData( 0 )\n          count--\n          if( count <= 0 ) { \n            console.log(\"Soundfont \" + obj.instrumentFileName + \" is loaded.\")\n            obj.isLoaded = true\n            if( obj.onload ) obj.onload()\n          }\n        }, function(e) { console.log(\"ERROR\", e.err, arguments, _note ) } )\n        \n      }()\n    }\n  }\n  \n  Gibberish.SoundFont = function( instrumentFileName, pathToResources ) {\n    var that = this\n    Gibberish.extend(this, {\n      'instrumentFileName': instrumentFileName,\n      name:'soundfont',\n      properties: {\n        amp:1,\n        pan:0\n      },\n      playing:[],\n      buffers:{},\n      onload: null,\n      out:[0,0],\n      isLoaded: false,\n      resourcePath: pathToResources || './resources/soundfonts/',\n      \n      callback: function( amp, pan ) {\n        var val = 0\n        for( var i = this.playing.length -1; i >= 0; i-- ) {\n          var note = this.playing[ i ]\n          \n          val += this.interpolate( note.buffer, note.phase ) * note.velocity\n          \n          note.phase += note.increment\n          if( note.phase > note.length ) {\n            this.playing.splice( this.playing.indexOf( note ), 1 )\n          }\n        }\n        \n        return this.panner( val * amp, pan, this.out );\n      }.bind( this ),\n      \n      note: function( name, velocity, cents ) {\n        if( this.isLoaded ) {\n          this.playing.push({\n            buffer:this.buffers[ name ],\n            phase:0,\n            increment: isNaN( cents ) ? 1 : 1 + cents,\n            length:this.buffers[ name ].length,\n            velocity: isNaN( velocity ) ? 1 : velocity\n          })\n        }\n      },\n      interpolate: Gibberish.interpolate.bind( this ),\n      panner: Gibberish.makePanner()\n    })\n    .init()\n    .oscillatorInit()\n    \n    if( typeof arguments[0] === 'object' && arguments[0].instrumentFileName ) {\n      this.instrumentFileName = arguments[0].instrumentFileName\n    }\n    \n    // if already loaded, or if passed a buffer to use...\n    if( !SF.instruments[ this.instrumentFileName ] && typeof this.resourcePath !== 'object' ) {\n      console.log(\"DOWNLOADING SOUNDFONT\")\n      getScript( this.resourcePath + this.instrumentFileName + '-mp3.js', decodeBuffers.bind( null, this ) )\n    }else{\n      if( typeof pathToResources === 'object' ) {\n        SF[ this.instrumentFileName ] = pathToResources\n        decodeBuffers( this )\n      }else{\n        this.buffers = SF.instruments[ this.instrumentFileName ]\n        this.isLoaded = true\n        setTimeout( function() { if( this.onload ) this.onload() }.bind( this ), 0 )\n      }\n    }\n    return this\n  }\n  Gibberish.SoundFont.storage = SF\n  Gibberish.SoundFont.prototype = Gibberish._oscillator;\n})()\n  \n\nGibberish.Vocoder = function() {\n  var encoders = [], decoders = [], amps = [], store = [], \n      abs = Math.abs, sqrt = Math.sqrt, phase = 0, output = [0,0],\n      encoderObjects = [], decoderObjects = [], envelopeSize = 128,\n      history = [],\n      sums = [],\n      env = [],\n      index = 0,\n      original_cutoffs = [\n        330, 440, 554, 880, 1100, 1660, 2220, 3140\n      ],\n      cutoffs = [],\n      startFreq = arguments[3] || 330,\n      endFreq   = arguments[4] || 3200,\n      numberOfBands = arguments[2] || 16,\n      Q = arguments[5] || .15;\n  \n\tthis.name =\t\"vocoder\";\n  \n\tthis.properties = {\n    carrier:  arguments[0] || null,\n    modulator:arguments[1] || null,\n    amp:\t\t  1,\n\t  pan:\t\t  0\n  }\n\n  // filter band formula adapted from https://github.com/cwilso/Vocoder/blob/master/js/vocoder.js\n\tvar totalRangeInCents = 1200 * Math.log( endFreq / startFreq ) / Math.LN2,\n\t    centsPerBand = totalRangeInCents / numberOfBands,\n\t    scale = Math.pow( 2, centsPerBand / 1200 ),  // This is the scaling for successive bands\n\t    currentFreq = startFreq;\n\n\tfor(var i = 0; i < numberOfBands; i++) {\n\t\tencoderObjects[i] = new Gibberish.Biquad({ mode:'BP', Q:Q, cutoff:currentFreq });\n    encoders[i] = encoderObjects[i].callback\n\t\tdecoderObjects[i] = new Gibberish.Biquad({ mode:'BP', Q:Q, cutoff:currentFreq });\n    decoders[i] = decoderObjects[i].callback    \n\t\t\n    history[ i ] = [ 0 ]\n    sums[ i ] = 0\n    env[ i ] = 0\n    \n\t\tcurrentFreq = currentFreq * scale;\n\t}\n  \n  //console.log( numberOfBands, startFreq, endFreq, Q )\n  \n  this.callback = function( carrier, modulator, amp, pan ) {\n    var historyIndex = ( index + 1 ) % envelopeSize,\n        modValue = typeof modulator !== 'number' ? modulator[0] + modulator[1] : modulator,\n        carrierValue = typeof carrier !== 'number' ? carrier[0] + carrier[1] : carrier,\n        encValue, out = 0\n        \n\t\tfor(var i = 0; i < numberOfBands; i++) {\n      encValue = abs( encoders[ i ]( modValue ) )\n      \n      sums[ i ] += encValue\n      sums[ i ] -= history[ i ][ index ]\n      \n      history[ i ][ index ] = encValue\n      history[ i ][ historyIndex ] = history[ i ][ historyIndex ] ? history[ i ][ historyIndex ] : 0\n      \n      env[ i ] = sums[ i ] / envelopeSize\n      \n      out += decoders[i]( carrierValue ) * env[ i ];\n\t\t}\n    index = historyIndex\n\t\n    output[0] = output[1] = out * amp * 16; // look, ma... 16 IS MAGIC!!!\n\n\t\treturn output;\n\t}\n  \n  this.getEncoders = function() { return encoderObjects }\n  this.getDecoders = function() { return decoderObjects }  \n  \n  this.init();\n  this.oscillatorInit();\n\t//this.processProperties(arguments);\n}\nGibberish.Vocoder.prototype = Gibberish._synth\nreturn Gibberish; \n})\n","//     keymaster.js\n//     (c) 2011-2013 Thomas Fuchs\n//     keymaster.js may be freely distributed under the MIT license.\n\n;(function(global){\n  var k,\n    _handlers = {},\n    _mods = { 16: false, 18: false, 17: false, 91: false },\n    _scope = 'all',\n    // modifier keys\n    _MODIFIERS = {\n      '': 16, shift: 16,\n      '': 18, alt: 18, option: 18,\n      '': 17, ctrl: 17, control: 17,\n      '': 91, command: 91\n    },\n    // special keys\n    _MAP = {\n      backspace: 8, tab: 9, clear: 12,\n      enter: 13, 'return': 13,\n      esc: 27, escape: 27, space: 32,\n      left: 37, up: 38,\n      right: 39, down: 40,\n      del: 46, 'delete': 46,\n      home: 36, end: 35,\n      pageup: 33, pagedown: 34,\n      ',': 188, '.': 190, '/': 191,\n      '`': 192, '-': 189, '=': 187,\n      ';': 186, '\\'': 222,\n      '[': 219, ']': 221, '\\\\': 220\n    },\n    code = function(x){\n      return _MAP[x] || x.toUpperCase().charCodeAt(0);\n    },\n    _downKeys = [];\n\n  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;\n\n  // IE doesn't support Array#indexOf, so have a simple replacement\n  function index(array, item){\n    var i = array.length;\n    while(i--) if(array[i]===item) return i;\n    return -1;\n  }\n\n  // for comparing mods before unassignment\n  function compareArray(a1, a2) {\n    if (a1.length != a2.length) return false;\n    for (var i = 0; i < a1.length; i++) {\n        if (a1[i] !== a2[i]) return false;\n    }\n    return true;\n  }\n\n  var modifierMap = {\n      16:'shiftKey',\n      18:'altKey',\n      17:'ctrlKey',\n      91:'metaKey'\n  };\n  function updateModifierKey(event) {\n      for(k in _mods) _mods[k] = event[modifierMap[k]];\n  };\n\n  // handle keydown event\n  function dispatch(event) {\n    var key, handler, k, i, modifiersMatch, scope;\n    key = event.keyCode;\n\n    if (index(_downKeys, key) == -1) {\n        _downKeys.push(key);\n    }\n\n    // if a modifier key, set the key.<modifierkeyname> property to true and return\n    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko\n    if(key in _mods) {\n      _mods[key] = true;\n      // 'assignKey' from inside this closure is exported to window.key\n      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;\n      return;\n    }\n    updateModifierKey(event);\n\n    // see if we need to ignore the keypress (filter() can can be overridden)\n    // by default ignore key presses if a select, textarea, or input is focused\n    if(!assignKey.filter.call(this, event)) return;\n\n    // abort if no potentially matching shortcuts found\n    if (!(key in _handlers)) return;\n\n    scope = getScope();\n\n    // for each potential shortcut\n    for (i = 0; i < _handlers[key].length; i++) {\n      handler = _handlers[key][i];\n\n      // see if it's in the current scope\n      if(handler.scope == scope || handler.scope == 'all'){\n        // check if modifiers match if any\n        modifiersMatch = handler.mods.length > 0;\n        for(k in _mods)\n          if((!_mods[k] && index(handler.mods, +k) > -1) ||\n            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;\n        // call the handler and stop the event if neccessary\n        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){\n          if(handler.method(event, handler)===false){\n            if(event.preventDefault) event.preventDefault();\n              else event.returnValue = false;\n            if(event.stopPropagation) event.stopPropagation();\n            if(event.cancelBubble) event.cancelBubble = true;\n          }\n        }\n      }\n    }\n  };\n\n  // unset modifier keys on keyup\n  function clearModifier(event){\n    var key = event.keyCode, k,\n        i = index(_downKeys, key);\n\n    // remove key from _downKeys\n    if (i >= 0) {\n        _downKeys.splice(i, 1);\n    }\n\n    if(key == 93 || key == 224) key = 91;\n    if(key in _mods) {\n      _mods[key] = false;\n      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;\n    }\n  };\n\n  function resetModifiers() {\n    for(k in _mods) _mods[k] = false;\n    for(k in _MODIFIERS) assignKey[k] = false;\n  };\n\n  // parse and assign shortcut\n  function assignKey(key, scope, method){\n    var keys, mods;\n    keys = getKeys(key);\n    if (method === undefined) {\n      method = scope;\n      scope = 'all';\n    }\n\n    // for each shortcut\n    for (var i = 0; i < keys.length; i++) {\n      // set modifier keys if any\n      mods = [];\n      key = keys[i].split('+');\n      if (key.length > 1){\n        mods = getMods(key);\n        key = [key[key.length-1]];\n      }\n      // convert to keycode and...\n      key = key[0]\n      key = code(key);\n      // ...store handler\n      if (!(key in _handlers)) _handlers[key] = [];\n      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });\n    }\n  };\n\n  // unbind all handlers for given key in current scope\n  function unbindKey(key, scope) {\n    var multipleKeys, keys,\n      mods = [],\n      i, j, obj;\n\n    multipleKeys = getKeys(key);\n\n    for (j = 0; j < multipleKeys.length; j++) {\n      keys = multipleKeys[j].split('+');\n\n      if (keys.length > 1) {\n        mods = getMods(keys);\n      }\n\n      key = keys[keys.length - 1];\n      key = code(key);\n\n      if (scope === undefined) {\n        scope = getScope();\n      }\n      if (!_handlers[key]) {\n        return;\n      }\n      for (i = 0; i < _handlers[key].length; i++) {\n        obj = _handlers[key][i];\n        // only clear handlers if correct scope and mods match\n        if (obj.scope === scope && compareArray(obj.mods, mods)) {\n          _handlers[key][i] = {};\n        }\n      }\n    }\n  };\n\n  // Returns true if the key with code 'keyCode' is currently down\n  // Converts strings into key codes.\n  function isPressed(keyCode) {\n      if (typeof(keyCode)=='string') {\n        keyCode = code(keyCode);\n      }\n      return index(_downKeys, keyCode) != -1;\n  }\n\n  function getPressedKeyCodes() {\n      return _downKeys.slice(0);\n  }\n\n  function filter(event){\n    var tagName = (event.target || event.srcElement).tagName;\n    // ignore keypressed in any elements that support keyboard data input\n    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');\n  }\n\n  // initialize key.<modifier> to false\n  for(k in _MODIFIERS) assignKey[k] = false;\n\n  // set current scope (default 'all')\n  function setScope(scope){ _scope = scope || 'all' };\n  function getScope(){ return _scope || 'all' };\n\n  // delete all handlers for a given scope\n  function deleteScope(scope){\n    var key, handlers, i;\n\n    for (key in _handlers) {\n      handlers = _handlers[key];\n      for (i = 0; i < handlers.length; ) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);\n        else i++;\n      }\n    }\n  };\n\n  // abstract key logic for assign and unassign\n  function getKeys(key) {\n    var keys;\n    key = key.replace(/\\s/g, '');\n    keys = key.split(',');\n    if ((keys[keys.length - 1]) == '') {\n      keys[keys.length - 2] += ',';\n    }\n    return keys;\n  }\n\n  // abstract mods logic for assign and unassign\n  function getMods(key) {\n    var mods = key.slice(0, key.length - 1);\n    for (var mi = 0; mi < mods.length; mi++)\n    mods[mi] = _MODIFIERS[mods[mi]];\n    return mods;\n  }\n\n  // cross-browser events\n  function addEvent(object, event, method) {\n    if (object.addEventListener)\n      object.addEventListener(event, method, false);\n    else if(object.attachEvent)\n      object.attachEvent('on'+event, function(){ method(window.event) });\n  };\n\n  // set the handlers globally on document\n  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48\n  addEvent(document, 'keyup', clearModifier);\n\n  // reset modifiers to false whenever the window is (re)focused.\n  addEvent(window, 'focus', resetModifiers);\n\n  // store previously defined key\n  var previousKey = global.key;\n\n  // restore previously defined key and return reference to our key object\n  function noConflict() {\n    var k = global.key;\n    global.key = previousKey;\n    return k;\n  }\n\n  // set window.key and window.key.set/get/deleteScope, and the default filter\n  global.key = assignKey;\n  global.key.setScope = setScope;\n  global.key.getScope = getScope;\n  global.key.deleteScope = deleteScope;\n  global.key.filter = filter;\n  global.key.isPressed = isPressed;\n  global.key.getPressedKeyCodes = getPressedKeyCodes;\n  global.key.noConflict = noConflict;\n  global.key.unbind = unbindKey;\n\n  if(typeof module !== 'undefined') module.exports = assignKey;\n\n})(this);\n","/* BE\n   https://github.com/Sonoport/soundmodels\n   cd src/lib/core\n   cat AudioContextMonkeyPatch.js WebAudioDispatch.js Config.js SPPlaybackRateParam.js SPAudioBufferSourceNode.js > sonoport-soundmodels-core-lite.js\n*/\n\n/**\n *\n *\n * @module Core\n *\n */\n\"use strict\";\n\n/*\n * A structure for static configuration options.\n *\n * @module Core\n * @class Config\n */\n\"use strict\";\n\nfunction Config() {}\n\n/**\n * Define if Errors are logged using errorception.\n *\n * @final\n * @static\n * @property LOG_ERRORS\n * @default true\n *\n */\nConfig.LOG_ERRORS = true;\n\n/**\n * Very small number considered non-zero by WebAudio.\n *\n * @final\n * @static\n * @property ZERO\n * @default 1e-37\n *\n */\nConfig.ZERO = parseFloat( '1e-37' );\n\n/**\n * Maximum number of voices supported\n *\n * @final\n * @static\n * @property MAX_VOICES\n * @default 8\n *\n */\nConfig.MAX_VOICES = 8;\n\n/**\n * Default nominal refresh rate (Hz) for SoundQueue.\n *\n * @final\n * @static\n * @property NOMINAL_REFRESH_RATE\n * @default 60\n *\n */\nConfig.NOMINAL_REFRESH_RATE = 60;\n\n/**\n * Default window length for window and add functionality\n *\n * @final\n * @static\n * @property NOMINAL_REFRESH_RATE\n * @default 512\n *\n */\nConfig.WINDOW_LENGTH = 512;\n\n/**\n * Default Chunk Length for ScriptNodes.\n *\n * @final\n * @static\n * @property CHUNK_LENGTH\n * @default 256\n *\n */\nConfig.CHUNK_LENGTH = 2048;\n\n/**\n * Default smoothing constant.\n *\n * @final\n * @static\n * @property CHUNK_LENGTH\n * @default 0.05\n *\n */\nConfig.DEFAULT_SMOOTHING_CONSTANT = 0.05;\n\n//BE module.exports = Config;\n/**\n * @module Core\n */\n\"use strict\";\n//BE var Config = require( '../core/Config' );\n\n/**\n * Wrapper around AudioParam playbackRate of SPAudioBufferSourceNode to help calculate the playbackPosition of the AudioBufferSourceNode.\n *\n * @class SPPlaybackRateParam\n * @constructor\n * @param {SPAudioBufferSourceNode} bufferSourceNode Reference to the parent SPAudioBufferSourceNode.\n * @param {AudioParam} audioParam The playbackRate of a source AudioBufferSourceNode.\n * @param {AudioParam} counterParam The playbackRate of counter AudioBufferSourceNode.\n */\nfunction SPPlaybackRateParam( bufferSourceNode, audioParam, counterParam ) {\n    this.defaultValue = audioParam.defaultValue;\n    this.maxValue = audioParam.maxValue;\n    this.minValue = audioParam.minValue;\n    this.name = audioParam.name;\n    this.units = audioParam.units;\n    this.isSPPlaybackRateParam = true;\n\n    Object.defineProperty( this, 'value', {\n        enumerable: true,\n        configurable: false,\n        set: function ( rate ) {\n            if ( bufferSourceNode.playbackState === bufferSourceNode.PLAYING_STATE ) {\n                audioParam.setTargetAtTime( rate, bufferSourceNode.audioContext.currentTime, Config.DEFAULT_SMOOTHING_CONSTANT );\n                counterParam.setTargetAtTime( rate, bufferSourceNode.audioContext.currentTime, Config.DEFAULT_SMOOTHING_CONSTANT );\n            } else {\n                audioParam.setValueAtTime( rate, bufferSourceNode.audioContext.currentTime );\n                counterParam.setValueAtTime( rate, bufferSourceNode.audioContext.currentTime );\n            }\n\n        },\n        get: function () {\n            return audioParam.value;\n        }\n    } );\n\n    audioParam.value = audioParam.value;\n    counterParam.value = audioParam.value;\n\n    this.linearRampToValueAtTime = function ( value, endTime ) {\n        audioParam.linearRampToValueAtTime( value, endTime );\n        counterParam.linearRampToValueAtTime( value, endTime );\n    };\n\n    this.exponentialRampToValueAtTime = function ( value, endTime ) {\n        audioParam.exponentialRampToValueAtTime( value, endTime );\n        counterParam.exponentialRampToValueAtTime( value, endTime );\n\n    };\n\n    this.setValueCurveAtTime = function ( values, startTime, duration ) {\n        audioParam.setValueCurveAtTime( values, startTime, duration );\n        counterParam.setValueCurveAtTime( values, startTime, duration );\n    };\n\n    this.setTargetAtTime = function ( target, startTime, timeConstant ) {\n        audioParam.setTargetAtTime( target, startTime, timeConstant );\n        counterParam.setTargetAtTime( target, startTime, timeConstant );\n\n    };\n\n    this.setValueAtTime = function ( value, time ) {\n        audioParam.setValueAtTime( value, time );\n        counterParam.setValueAtTime( value, time );\n    };\n\n    this.cancelScheduledValues = function ( time ) {\n        audioParam.cancelScheduledValues( time );\n        counterParam.cancelScheduledValues( time );\n    };\n}\n//BE module.exports = SPPlaybackRateParam;\n/**\n * @module Core\n */\n\n\"use strict\";\n//BE var SPPlaybackRateParam = require( '../core/SPPlaybackRateParam' );\n//BE var webAudioDispatch = require( '../core/WebAudioDispatch' );\n//BE var log = require( 'loglevel' );\n\n/**\n * A wrapper around the AudioBufferSourceNode to be able to track the current playPosition of a AudioBufferSourceNode.\n *\n * @class SPAudioBufferSourceNode\n * @constructor\n * @param {AudioContext} AudioContext to be used in timing the parameter automation events\n */\nfunction SPAudioBufferSourceNode( audioContext ) {\n    var bufferSourceNode_ = audioContext.createBufferSource();\n    var counterNode_;\n\n    var scopeNode_ = audioContext.createScriptProcessor( 256, 1, 1 );\n    var trackGainNode_ = audioContext.createGain();\n    var lastPos = 0;\n\n    this.audioContext = audioContext;\n    this.playbackState = 0;\n\n    this.channelCount = null;\n    this.channelCountMode = null;\n    this.channelInterpretation = null;\n    this.numberOfInputs = null;\n    this.numberOfOutputs = null;\n\n    /**\n     * Playback States Constant.\n     *\n     * @property UNSCHEDULED_STATE\n     * @type Number\n     * @default \"Model\"\n     **/\n    this.UNSCHEDULED_STATE = 0;\n\n    /**\n     * Playback States Constant.\n     *\n     * @property SCHEDULED_STATE\n     * @type Number\n     * @default \"1\"\n     **/\n    this.SCHEDULED_STATE = 1;\n\n    /**\n     * Playback States Constant.\n     *\n     * @property PLAYING_STATE\n     * @type Number\n     * @default \"2\"\n     **/\n    this.PLAYING_STATE = 2;\n\n    /**\n     * Playback States Constant.\n     *\n     * @property FINISHED_STATE\n     * @type Number\n     * @default \"3\"\n     **/\n    this.FINISHED_STATE = 3;\n\n    /**\n     * The speed at which to render the audio stream. Its default value is 1. This parameter is a-rate.\n     *\n     * @property playbackRate\n     * @type AudioParam\n     * @default 1\n     *\n     */\n    this.playbackRate = null;\n\n    /**\n     * An optional value in seconds where looping should end if the loop attribute is true.\n     *\n     * @property loopEnd\n     * @type Number\n     * @default 0\n     *\n     */\n    Object.defineProperty( this, 'loopEnd', {\n        enumerable: true,\n        configurable: false,\n        set: function ( loopEnd ) {\n            bufferSourceNode_.loopEnd = loopEnd;\n            counterNode_.loopEnd = loopEnd;\n        },\n        get: function () {\n            return bufferSourceNode_.loopEnd;\n        }\n    } );\n\n    /**\n     * An optional value in seconds where looping should begin if the loop attribute is true.\n     *\n     * @property loopStart\n     * @type Number\n     * @default 0\n     *\n     */\n    Object.defineProperty( this, 'loopStart', {\n        enumerable: true,\n        configurable: false,\n        set: function ( loopStart ) {\n            bufferSourceNode_.loopStart = loopStart;\n            counterNode_.loopStart = loopStart;\n        },\n        get: function () {\n            return bufferSourceNode_.loopStart;\n        }\n    } );\n\n    /**\n     * A property used to set the EventHandler for the ended event that is dispatched to AudioBufferSourceNode node types\n     *\n     * @property onended\n     * @type Function\n     * @default null\n     *\n     */\n    Object.defineProperty( this, 'onended', {\n        enumerable: true,\n        configurable: false,\n        set: function ( onended ) {\n            bufferSourceNode_.onended = wrapAroundOnEnded( this, onended );\n        },\n        get: function () {\n            return bufferSourceNode_.onended;\n        }\n    } );\n\n    /**\n     * Indicates if the audio data should play in a loop.\n     *\n     * @property loop\n     * @type Boolean\n     * @default false\n     *\n     */\n    Object.defineProperty( this, 'loop', {\n        enumerable: true,\n        configurable: false,\n        set: function ( loop ) {\n            bufferSourceNode_.loop = loop;\n            counterNode_.loop = loop;\n        },\n        get: function () {\n            return bufferSourceNode_.loop;\n        }\n    } );\n\n    /**\n     * Position (in seconds) of the last frame played back by the AudioContext\n     *\n     * @property playbackPosition\n     * @type Number\n     * @default 0\n     *\n     */\n    Object.defineProperty( this, 'playbackPosition', {\n        enumerable: true,\n        configurable: false,\n        get: function () {\n            return lastPos;\n        }\n    } );\n\n    /**\n     * Represents the audio asset to be played.\n     *\n     * @property buffer\n     * @type AudioBuffer\n     * @default null\n     *\n     */\n    Object.defineProperty( this, 'buffer', {\n        enumerable: true,\n        configurable: false,\n        set: function ( buffer ) {\n            if ( bufferSourceNode_ ) {\n                bufferSourceNode_.disconnect();\n            }\n\n            if ( counterNode_ ) {\n                counterNode_.disconnect();\n            }\n\n            bufferSourceNode_ = audioContext.createBufferSource();\n            counterNode_ = audioContext.createBufferSource();\n            if ( buffer.isSPAudioBuffer ) {\n                bufferSourceNode_.buffer = buffer.buffer;\n                counterNode_.buffer = createCounterBuffer( buffer.buffer );\n            } else if ( buffer instanceof AudioBuffer ) {\n                bufferSourceNode_.buffer = buffer;\n                counterNode_.buffer = createCounterBuffer( buffer );\n            }\n\n            counterNode_.connect( scopeNode_ );\n            bufferSourceNode_.connect( trackGainNode_ );\n\n            this.channelCount = bufferSourceNode_.channelCount;\n            this.channelCountMode = bufferSourceNode_.channelCountMode;\n            this.channelInterpretation = bufferSourceNode_.channelInterpretation;\n            this.numberOfInputs = bufferSourceNode_.numberOfInputs;\n            this.numberOfOutputs = bufferSourceNode_.numberOfOutputs;\n\n          this.playbackRate = new SPPlaybackRateParam( this, bufferSourceNode_.playbackRate, counterNode_.playbackRate );\n        },\n      get: function () {\n\t//console.log(\"get: \", bufferSourceNode_.buffer);\n            return bufferSourceNode_.buffer;\n        }\n    } );\n\n    /**\n     * Track gain for this specific buffer.\n     *\n     * @property buffer\n     * @type AudioBuffer\n     * @default null\n     *\n     */\n    Object.defineProperty( this, 'gain', {\n        enumerable: true,\n        configurable: false,\n        set: function(gain) { //BE\n  \t    trackGainNode_.gain.value = gain;\n\t}, \n        get: function () {\n            return trackGainNode_.gain;\n        }\n    } );\n\n    /**\n     * Connects the AudioNode to the input of another AudioNode.\n     *\n     * @method connect\n     * @param {AudioNode} destination AudioNode to connect to.\n     * @param {Number} [output] Index describing which output of the AudioNode from which to connect.\n     * @param {Number} [input] Index describing which input of the destination AudioNode to connect to.\n     *\n     */\n    this.connect = function ( destination, output, input ) {\n        trackGainNode_.connect( destination, output, input );\n    };\n\n    /**\n     * Disconnects the AudioNode from the input of another AudioNode.\n     *\n     * @method disconnect\n     * @param {Number} [output] Index describing which output of the AudioNode to disconnect.\n     *\n     */\n    this.disconnect = function ( output ) {\n        trackGainNode_.disconnect( output );\n    };\n\n    /**\n     * Start playback //BE\n     *\n     * @method start\n     *\n     */\n    this.start = function () {\n      bufferSourceNode_.start( );\n      counterNode_.start();\n      this.playbackState = this.PLAYING_STATE;\n    };\n\n    /**\n     * Stop playback //BE\n     *\n     * @method stop\n     *\n     */\n    this.stop = function () {\n        if ( this.playbackState === this.PLAYING_STATE || this.playbackState === this.SCHEDULED_STATE ) {\n            bufferSourceNode_.stop();\n            counterNode_.stop();\n        }\n    };\n\n    /**\n     * Resets the SP Buffer Source with a fresh BufferSource.\n     *\n     * @method resetBufferSource\n     * @param {Number} when Time (in seconds) when the Buffer source should be reset.\n     * @param {AudioNode} output The output to which the BufferSource is to be connected.\n     *\n     */\n    this.resetBufferSource = function ( when, output ) {\n\n        var self = this;\n        webAudioDispatch( function () {\n            //BE log.debug( 'Resetting BufferSource', self.buffer.length );\n            // Disconnect source(s) from output.\n\n            // Disconnect scope node from trackGain\n            scopeNode_.disconnect();\n\n            var newTrackGain = self.audioContext.createGain();\n            newTrackGain.gain.value = trackGainNode_.gain.value;\n            trackGainNode_ = newTrackGain;\n\n            // Create new sources and copy all the parameters over.\n            var newSource = self.audioContext.createBufferSource();\n            newSource.buffer = bufferSourceNode_.buffer;\n            newSource.loopStart = bufferSourceNode_.loopStart;\n            newSource.loopEnd = bufferSourceNode_.loopEnd;\n            newSource.onended = wrapAroundOnEnded( self, bufferSourceNode_.onended );\n\n            // Remove onended callback from old buffer\n            bufferSourceNode_.onended = null;\n\n            // Throw away the counter node;\n            counterNode_.disconnect();\n\n            var newCounterNode = audioContext.createBufferSource();\n            newCounterNode.buffer = counterNode_.buffer;\n\n            // Assign the new local variables to new sources\n            bufferSourceNode_ = newSource;\n            counterNode_ = newCounterNode;\n\n            // Create new parameters for rate parameter\n            var playBackRateVal = self.playbackRate.value;\n            self.playbackRate = new SPPlaybackRateParam( self, bufferSourceNode_.playbackRate, counterNode_.playbackRate );\n            self.playbackRate.setValueAtTime( playBackRateVal, 0 );\n\n            // Reconnect to output.\n            counterNode_.connect( scopeNode_ );\n            bufferSourceNode_.connect( trackGainNode_ );\n            scopeNode_.connect( trackGainNode_ );\n            self.connect( output );\n            self.playbackState = self.UNSCHEDULED_STATE;\n        }, when, this.audioContext );\n    };\n\n    // Private Methods\n\n    function createCounterBuffer( buffer ) {\n        var array = new Float32Array( buffer.length );\n        var audioBuf = audioContext.createBuffer( 1, buffer.length, 44100 );\n\n        for ( var index = 0; index < buffer.length; index++ ) {\n            array[ index ] = index;\n        }\n\n        audioBuf.getChannelData( 0 ).set( array );\n        return audioBuf;\n    }\n\n    function init() {\n        scopeNode_.connect( trackGainNode_ );\n        scopeNode_.onaudioprocess = savePosition;\n    }\n\n    function savePosition( processEvent ) {\n        var inputBuffer = processEvent.inputBuffer.getChannelData( 0 );\n        lastPos = inputBuffer[ inputBuffer.length - 1 ] || 0;\n    }\n\n    function wrapAroundOnEnded( node, onended ) {\n        return function ( event ) {\n            node.playbackState = node.FINISHED_STATE;\n            if ( typeof onended === 'function' ) {\n                onended( event );\n            }\n        };\n    }\n\n    init();\n\n}\n//BE module.exports = SPAudioBufferSourceNode;\n"]}